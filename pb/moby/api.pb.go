// Code generated by protoc-gen-gogo.
// source: pb/moby/api.proto
// DO NOT EDIT!

/*
	Package moby is a generated protocol buffer package.

	It is generated from these files:
		pb/moby/api.proto

	It has these top-level messages:
		HealthConfig
		Config
		LogConfig
		RestartPolicy
		Resources
		DeviceMapping
		HostConfig
		PortBinding
		PortMap
		PortSet
		VolumeMount
		BindOptions
		VolumeOptions
		DriverConfig
		TmpfsOptions
		WeightDevice
		ThrottleDevice
		Ulimit
		NetworkingConfig
		EndpointSettings
		EndpointIPAMConfig
*/
package moby

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// HealthConfig holds configuration settings for the HEALTHCHECK feature.
// to see https://github.com/moby/moby/blob/master/api/types/container/config.go
type HealthConfig struct {
	// Test is the test to perform to check that the container is healthy.
	// An empty slice means to inherit the default.
	// The options are:
	// {} : inherit healthcheck
	// {"NONE"} : disable healthcheck
	// {"CMD", args...} : exec arguments directly
	// {"CMD-SHELL", command} : run command with system's default shell
	Test []string `protobuf:"bytes,1,rep,name=test" json:"test,omitempty"`
	// Zero means to inherit. Durations are expressed as integer nanoseconds.
	// Golang    time.Duration
	// Interval is the time to wait between checks.
	IntervalSeconds int64 `protobuf:"varint,2,opt,name=interval_seconds,json=intervalSeconds,proto3" json:"interval_seconds,omitempty"`
	// Golang     time.Duration
	// Timeout is the time to wait before considering the check to have hung.
	TimeoutSeconds int64 `protobuf:"varint,3,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
	// Golang time.Duration
	// The start period for the container to initialize before the retries starts to count down.
	StartPeriod int64 `protobuf:"varint,4,opt,name=start_period,json=startPeriod,proto3" json:"start_period,omitempty"`
	// Retries is the number of consecutive failures needed to consider a container as unhealthy.
	// Zero means inherit.
	Retries int32 `protobuf:"varint,5,opt,name=retries,proto3" json:"retries,omitempty"`
}

func (m *HealthConfig) Reset()                    { *m = HealthConfig{} }
func (m *HealthConfig) String() string            { return proto.CompactTextString(m) }
func (*HealthConfig) ProtoMessage()               {}
func (*HealthConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

func (m *HealthConfig) GetTest() []string {
	if m != nil {
		return m.Test
	}
	return nil
}

func (m *HealthConfig) GetIntervalSeconds() int64 {
	if m != nil {
		return m.IntervalSeconds
	}
	return 0
}

func (m *HealthConfig) GetTimeoutSeconds() int64 {
	if m != nil {
		return m.TimeoutSeconds
	}
	return 0
}

func (m *HealthConfig) GetStartPeriod() int64 {
	if m != nil {
		return m.StartPeriod
	}
	return 0
}

func (m *HealthConfig) GetRetries() int32 {
	if m != nil {
		return m.Retries
	}
	return 0
}

// Config contains the configuration data about a container.
// It should hold only portable information about the container.
// Here, "portable" means "independent from the host we are running on".
// Non-portable information *should* appear in HostConfig.
// All fields added to this struct must be marked 'omitempty' to keep getting
// predictable hashes from the old 'v1Compatibility' configuration.
// to see https://github.com/moby/moby/blob/master/api/types/container/config.go
type Config struct {
	Hostname        string                  `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Domainname      string                  `protobuf:"bytes,2,opt,name=domainname,proto3" json:"domainname,omitempty"`
	User            string                  `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	AttachStdin     bool                    `protobuf:"varint,4,opt,name=attach_stdin,json=attachStdin,proto3" json:"attach_stdin,omitempty"`
	AttachStdout    bool                    `protobuf:"varint,5,opt,name=attach_stdout,json=attachStdout,proto3" json:"attach_stdout,omitempty"`
	AttachStderr    bool                    `protobuf:"varint,6,opt,name=attach_stderr,json=attachStderr,proto3" json:"attach_stderr,omitempty"`
	ExposedPorts    *PortSet                `protobuf:"bytes,7,opt,name=exposed_ports,json=exposedPorts" json:"exposed_ports,omitempty"`
	Tty             bool                    `protobuf:"varint,8,opt,name=tty,proto3" json:"tty,omitempty"`
	OpenStdin       bool                    `protobuf:"varint,9,opt,name=open_stdin,json=openStdin,proto3" json:"open_stdin,omitempty"`
	StdinOnce       bool                    `protobuf:"varint,10,opt,name=stdin_once,json=stdinOnce,proto3" json:"stdin_once,omitempty"`
	Env             []string                `protobuf:"bytes,11,rep,name=env" json:"env,omitempty"`
	Cmd             []string                `protobuf:"bytes,12,rep,name=cmd" json:"cmd,omitempty"`
	Healthcheck     *HealthConfig           `protobuf:"bytes,13,opt,name=healthcheck" json:"healthcheck,omitempty"`
	ArgsEscaped     bool                    `protobuf:"varint,14,opt,name=args_escaped,json=argsEscaped,proto3" json:"args_escaped,omitempty"`
	Image           string                  `protobuf:"bytes,15,opt,name=image,proto3" json:"image,omitempty"`
	Volumes         map[string]*VolumeMount `protobuf:"bytes,16,rep,name=volumes" json:"volumes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	WorkingDir      string                  `protobuf:"bytes,17,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	Entrypoint      []string                `protobuf:"bytes,18,rep,name=entrypoint" json:"entrypoint,omitempty"`
	NetworkDisabled bool                    `protobuf:"varint,19,opt,name=network_disabled,json=networkDisabled,proto3" json:"network_disabled,omitempty"`
	MacAddress      string                  `protobuf:"bytes,20,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	OnBuild         []string                `protobuf:"bytes,21,rep,name=on_build,json=onBuild" json:"on_build,omitempty"`
	Labels          map[string]string       `protobuf:"bytes,22,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StopSignal      string                  `protobuf:"bytes,23,opt,name=stop_signal,json=stopSignal,proto3" json:"stop_signal,omitempty"`
	StopTimeout     int32                   `protobuf:"varint,24,opt,name=stop_timeout,json=stopTimeout,proto3" json:"stop_timeout,omitempty"`
	Shell           []string                `protobuf:"bytes,25,rep,name=shell" json:"shell,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

func (m *Config) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Config) GetDomainname() string {
	if m != nil {
		return m.Domainname
	}
	return ""
}

func (m *Config) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Config) GetAttachStdin() bool {
	if m != nil {
		return m.AttachStdin
	}
	return false
}

func (m *Config) GetAttachStdout() bool {
	if m != nil {
		return m.AttachStdout
	}
	return false
}

func (m *Config) GetAttachStderr() bool {
	if m != nil {
		return m.AttachStderr
	}
	return false
}

func (m *Config) GetExposedPorts() *PortSet {
	if m != nil {
		return m.ExposedPorts
	}
	return nil
}

func (m *Config) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (m *Config) GetOpenStdin() bool {
	if m != nil {
		return m.OpenStdin
	}
	return false
}

func (m *Config) GetStdinOnce() bool {
	if m != nil {
		return m.StdinOnce
	}
	return false
}

func (m *Config) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Config) GetCmd() []string {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Config) GetHealthcheck() *HealthConfig {
	if m != nil {
		return m.Healthcheck
	}
	return nil
}

func (m *Config) GetArgsEscaped() bool {
	if m != nil {
		return m.ArgsEscaped
	}
	return false
}

func (m *Config) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Config) GetVolumes() map[string]*VolumeMount {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *Config) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *Config) GetEntrypoint() []string {
	if m != nil {
		return m.Entrypoint
	}
	return nil
}

func (m *Config) GetNetworkDisabled() bool {
	if m != nil {
		return m.NetworkDisabled
	}
	return false
}

func (m *Config) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *Config) GetOnBuild() []string {
	if m != nil {
		return m.OnBuild
	}
	return nil
}

func (m *Config) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Config) GetStopSignal() string {
	if m != nil {
		return m.StopSignal
	}
	return ""
}

func (m *Config) GetStopTimeout() int32 {
	if m != nil {
		return m.StopTimeout
	}
	return 0
}

func (m *Config) GetShell() []string {
	if m != nil {
		return m.Shell
	}
	return nil
}

// LogConfig represents the logging configuration of the container.
// to see https://github.com/moby/moby/blob/master/api/types/container/host_config.go
type LogConfig struct {
	ConfigType string            `protobuf:"bytes,1,opt,name=config_type,json=configType,proto3" json:"config_type,omitempty"`
	Config     map[string]string `protobuf:"bytes,2,rep,name=config" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *LogConfig) Reset()                    { *m = LogConfig{} }
func (m *LogConfig) String() string            { return proto.CompactTextString(m) }
func (*LogConfig) ProtoMessage()               {}
func (*LogConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

func (m *LogConfig) GetConfigType() string {
	if m != nil {
		return m.ConfigType
	}
	return ""
}

func (m *LogConfig) GetConfig() map[string]string {
	if m != nil {
		return m.Config
	}
	return nil
}

// RestartPolicy represents the restart policies of the container.
type RestartPolicy struct {
	Name              string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	MaximumRetryCount int32  `protobuf:"varint,2,opt,name=maximum_retry_count,json=maximumRetryCount,proto3" json:"maximum_retry_count,omitempty"`
}

func (m *RestartPolicy) Reset()                    { *m = RestartPolicy{} }
func (m *RestartPolicy) String() string            { return proto.CompactTextString(m) }
func (*RestartPolicy) ProtoMessage()               {}
func (*RestartPolicy) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

func (m *RestartPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RestartPolicy) GetMaximumRetryCount() int32 {
	if m != nil {
		return m.MaximumRetryCount
	}
	return 0
}

// Resources contains container's resources (cgroups config, ulimits...)
// to see https://github.com/moby/moby/blob/master/api/types/container/host_config.go
type Resources struct {
	// Applicable to all platforms
	CpuShares int64 `protobuf:"varint,1,opt,name=cpu_shares,json=cpuShares,proto3" json:"cpu_shares,omitempty"`
	Memory    int64 `protobuf:"varint,2,opt,name=memory,proto3" json:"memory,omitempty"`
	NanoCpus  int64 `protobuf:"varint,3,opt,name=nano_cpus,json=nanoCpus,proto3" json:"nano_cpus,omitempty"`
	// Applicable to UNIX platforms
	CgroupParent         string           `protobuf:"bytes,4,opt,name=cgroup_parent,json=cgroupParent,proto3" json:"cgroup_parent,omitempty"`
	BlkioWeight          int32            `protobuf:"varint,5,opt,name=blkio_weight,json=blkioWeight,proto3" json:"blkio_weight,omitempty"`
	BlkioWeightDevice    *WeightDevice    `protobuf:"bytes,6,opt,name=blkio_weight_device,json=blkioWeightDevice" json:"blkio_weight_device,omitempty"`
	BlkioDeviceReadBps   *ThrottleDevice  `protobuf:"bytes,7,opt,name=blkio_device_read_bps,json=blkioDeviceReadBps" json:"blkio_device_read_bps,omitempty"`
	BlkioDeviceWriteBps  *ThrottleDevice  `protobuf:"bytes,8,opt,name=blkio_device_write_bps,json=blkioDeviceWriteBps" json:"blkio_device_write_bps,omitempty"`
	BlkioDeviceReadIops  *ThrottleDevice  `protobuf:"bytes,9,opt,name=blkio_device_read_iops,json=blkioDeviceReadIops" json:"blkio_device_read_iops,omitempty"`
	BlkioDeviceWriteIops *ThrottleDevice  `protobuf:"bytes,10,opt,name=blkio_device_write_iops,json=blkioDeviceWriteIops" json:"blkio_device_write_iops,omitempty"`
	CpuPeriod            int64            `protobuf:"varint,11,opt,name=cpu_period,json=cpuPeriod,proto3" json:"cpu_period,omitempty"`
	CpuQuota             int64            `protobuf:"varint,12,opt,name=cpu_quota,json=cpuQuota,proto3" json:"cpu_quota,omitempty"`
	CpuRealtimePeriod    int64            `protobuf:"varint,13,opt,name=cpu_realtime_period,json=cpuRealtimePeriod,proto3" json:"cpu_realtime_period,omitempty"`
	CpuRealtimeRuntime   int64            `protobuf:"varint,14,opt,name=cpu_realtime_runtime,json=cpuRealtimeRuntime,proto3" json:"cpu_realtime_runtime,omitempty"`
	CpusetCpus           string           `protobuf:"bytes,15,opt,name=cpuset_cpus,json=cpusetCpus,proto3" json:"cpuset_cpus,omitempty"`
	CpusetMems           string           `protobuf:"bytes,16,opt,name=cpuset_mems,json=cpusetMems,proto3" json:"cpuset_mems,omitempty"`
	Devices              []*DeviceMapping `protobuf:"bytes,17,rep,name=devices" json:"devices,omitempty"`
	DeviceCgroupRules    []string         `protobuf:"bytes,18,rep,name=device_cgroup_rules,json=deviceCgroupRules" json:"device_cgroup_rules,omitempty"`
	DiskQuota            int64            `protobuf:"varint,19,opt,name=disk_quota,json=diskQuota,proto3" json:"disk_quota,omitempty"`
	KernelMemory         int64            `protobuf:"varint,20,opt,name=kernel_memory,json=kernelMemory,proto3" json:"kernel_memory,omitempty"`
	MemoryReservation    int64            `protobuf:"varint,21,opt,name=memory_reservation,json=memoryReservation,proto3" json:"memory_reservation,omitempty"`
	MemorySwap           int64            `protobuf:"varint,22,opt,name=memory_swap,json=memorySwap,proto3" json:"memory_swap,omitempty"`
	MemorySwappiness     int64            `protobuf:"varint,23,opt,name=memory_swappiness,json=memorySwappiness,proto3" json:"memory_swappiness,omitempty"`
	OomKillDisable       int64            `protobuf:"varint,24,opt,name=oom_kill_disable,json=oomKillDisable,proto3" json:"oom_kill_disable,omitempty"`
	PidsLimit            int64            `protobuf:"varint,25,opt,name=pids_limit,json=pidsLimit,proto3" json:"pids_limit,omitempty"`
	Ulimits              []*Ulimit        `protobuf:"bytes,26,rep,name=ulimits" json:"ulimits,omitempty"`
	// Applicable to Windows
	CpuCount           int64  `protobuf:"varint,27,opt,name=cpu_count,json=cpuCount,proto3" json:"cpu_count,omitempty"`
	CpuPercent         int64  `protobuf:"varint,28,opt,name=cpu_percent,json=cpuPercent,proto3" json:"cpu_percent,omitempty"`
	IoMaximumIops      uint64 `protobuf:"varint,29,opt,name=io_maximum_iops,json=ioMaximumIops,proto3" json:"io_maximum_iops,omitempty"`
	IoMaximumBandwidth uint64 `protobuf:"varint,30,opt,name=io_maximum_bandwidth,json=ioMaximumBandwidth,proto3" json:"io_maximum_bandwidth,omitempty"`
}

func (m *Resources) Reset()                    { *m = Resources{} }
func (m *Resources) String() string            { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()               {}
func (*Resources) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

func (m *Resources) GetCpuShares() int64 {
	if m != nil {
		return m.CpuShares
	}
	return 0
}

func (m *Resources) GetMemory() int64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Resources) GetNanoCpus() int64 {
	if m != nil {
		return m.NanoCpus
	}
	return 0
}

func (m *Resources) GetCgroupParent() string {
	if m != nil {
		return m.CgroupParent
	}
	return ""
}

func (m *Resources) GetBlkioWeight() int32 {
	if m != nil {
		return m.BlkioWeight
	}
	return 0
}

func (m *Resources) GetBlkioWeightDevice() *WeightDevice {
	if m != nil {
		return m.BlkioWeightDevice
	}
	return nil
}

func (m *Resources) GetBlkioDeviceReadBps() *ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceReadBps
	}
	return nil
}

func (m *Resources) GetBlkioDeviceWriteBps() *ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceWriteBps
	}
	return nil
}

func (m *Resources) GetBlkioDeviceReadIops() *ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceReadIops
	}
	return nil
}

func (m *Resources) GetBlkioDeviceWriteIops() *ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceWriteIops
	}
	return nil
}

func (m *Resources) GetCpuPeriod() int64 {
	if m != nil {
		return m.CpuPeriod
	}
	return 0
}

func (m *Resources) GetCpuQuota() int64 {
	if m != nil {
		return m.CpuQuota
	}
	return 0
}

func (m *Resources) GetCpuRealtimePeriod() int64 {
	if m != nil {
		return m.CpuRealtimePeriod
	}
	return 0
}

func (m *Resources) GetCpuRealtimeRuntime() int64 {
	if m != nil {
		return m.CpuRealtimeRuntime
	}
	return 0
}

func (m *Resources) GetCpusetCpus() string {
	if m != nil {
		return m.CpusetCpus
	}
	return ""
}

func (m *Resources) GetCpusetMems() string {
	if m != nil {
		return m.CpusetMems
	}
	return ""
}

func (m *Resources) GetDevices() []*DeviceMapping {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *Resources) GetDeviceCgroupRules() []string {
	if m != nil {
		return m.DeviceCgroupRules
	}
	return nil
}

func (m *Resources) GetDiskQuota() int64 {
	if m != nil {
		return m.DiskQuota
	}
	return 0
}

func (m *Resources) GetKernelMemory() int64 {
	if m != nil {
		return m.KernelMemory
	}
	return 0
}

func (m *Resources) GetMemoryReservation() int64 {
	if m != nil {
		return m.MemoryReservation
	}
	return 0
}

func (m *Resources) GetMemorySwap() int64 {
	if m != nil {
		return m.MemorySwap
	}
	return 0
}

func (m *Resources) GetMemorySwappiness() int64 {
	if m != nil {
		return m.MemorySwappiness
	}
	return 0
}

func (m *Resources) GetOomKillDisable() int64 {
	if m != nil {
		return m.OomKillDisable
	}
	return 0
}

func (m *Resources) GetPidsLimit() int64 {
	if m != nil {
		return m.PidsLimit
	}
	return 0
}

func (m *Resources) GetUlimits() []*Ulimit {
	if m != nil {
		return m.Ulimits
	}
	return nil
}

func (m *Resources) GetCpuCount() int64 {
	if m != nil {
		return m.CpuCount
	}
	return 0
}

func (m *Resources) GetCpuPercent() int64 {
	if m != nil {
		return m.CpuPercent
	}
	return 0
}

func (m *Resources) GetIoMaximumIops() uint64 {
	if m != nil {
		return m.IoMaximumIops
	}
	return 0
}

func (m *Resources) GetIoMaximumBandwidth() uint64 {
	if m != nil {
		return m.IoMaximumBandwidth
	}
	return 0
}

// DeviceMapping represents the device mapping between the host and the container.
type DeviceMapping struct {
	PathOnHost        string `protobuf:"bytes,1,opt,name=path_on_host,json=pathOnHost,proto3" json:"path_on_host,omitempty"`
	PathInContainer   string `protobuf:"bytes,2,opt,name=path_in_container,json=pathInContainer,proto3" json:"path_in_container,omitempty"`
	CgroupPermissions string `protobuf:"bytes,3,opt,name=cgroup_permissions,json=cgroupPermissions,proto3" json:"cgroup_permissions,omitempty"`
}

func (m *DeviceMapping) Reset()                    { *m = DeviceMapping{} }
func (m *DeviceMapping) String() string            { return proto.CompactTextString(m) }
func (*DeviceMapping) ProtoMessage()               {}
func (*DeviceMapping) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

func (m *DeviceMapping) GetPathOnHost() string {
	if m != nil {
		return m.PathOnHost
	}
	return ""
}

func (m *DeviceMapping) GetPathInContainer() string {
	if m != nil {
		return m.PathInContainer
	}
	return ""
}

func (m *DeviceMapping) GetCgroupPermissions() string {
	if m != nil {
		return m.CgroupPermissions
	}
	return ""
}

// HostConfig the non-portable Config structure of a container.
// Here, "non-portable" means "dependent of the host we are running on".
// Portable information *should* appear in Config.
// to see https://github.com/moby/moby/blob/master/api/types/container/host_config.go
type HostConfig struct {
	// Applicable to all platforms
	Binds           []string       `protobuf:"bytes,1,rep,name=binds" json:"binds,omitempty"`
	ContainerIdFile string         `protobuf:"bytes,2,opt,name=container_id_file,json=containerIdFile,proto3" json:"container_id_file,omitempty"`
	LogConfig       *LogConfig     `protobuf:"bytes,3,opt,name=log_config,json=logConfig" json:"log_config,omitempty"`
	NetworkMode     string         `protobuf:"bytes,4,opt,name=network_mode,json=networkMode,proto3" json:"network_mode,omitempty"`
	PortBindings    *PortMap       `protobuf:"bytes,5,opt,name=port_bindings,json=portBindings" json:"port_bindings,omitempty"`
	RestartPolicy   *RestartPolicy `protobuf:"bytes,6,opt,name=restart_policy,json=restartPolicy" json:"restart_policy,omitempty"`
	AutoRemove      bool           `protobuf:"varint,7,opt,name=auto_remove,json=autoRemove,proto3" json:"auto_remove,omitempty"`
	VolumeDriver    string         `protobuf:"bytes,8,opt,name=volume_driver,json=volumeDriver,proto3" json:"volume_driver,omitempty"`
	VolumesFrom     []string       `protobuf:"bytes,9,rep,name=volumes_from,json=volumesFrom" json:"volumes_from,omitempty"`
	// Applicable to UNIX platforms
	CapAdd          []string          `protobuf:"bytes,10,rep,name=cap_add,json=capAdd" json:"cap_add,omitempty"`
	CapDrop         []string          `protobuf:"bytes,11,rep,name=cap_drop,json=capDrop" json:"cap_drop,omitempty"`
	Dns             []string          `protobuf:"bytes,12,rep,name=dns" json:"dns,omitempty"`
	DnsOptions      []string          `protobuf:"bytes,13,rep,name=dns_options,json=dnsOptions" json:"dns_options,omitempty"`
	DnsSearch       []string          `protobuf:"bytes,14,rep,name=dns_search,json=dnsSearch" json:"dns_search,omitempty"`
	ExtraHosts      []string          `protobuf:"bytes,15,rep,name=extra_hosts,json=extraHosts" json:"extra_hosts,omitempty"`
	GroupAdd        []string          `protobuf:"bytes,16,rep,name=group_add,json=groupAdd" json:"group_add,omitempty"`
	IpcMode         string            `protobuf:"bytes,17,opt,name=ipc_mode,json=ipcMode,proto3" json:"ipc_mode,omitempty"`
	Cgroup          string            `protobuf:"bytes,18,opt,name=cgroup,proto3" json:"cgroup,omitempty"`
	Links           []string          `protobuf:"bytes,19,rep,name=links" json:"links,omitempty"`
	OomScoreAdj     int32             `protobuf:"varint,20,opt,name=oom_score_adj,json=oomScoreAdj,proto3" json:"oom_score_adj,omitempty"`
	PidMode         string            `protobuf:"bytes,21,opt,name=pid_mode,json=pidMode,proto3" json:"pid_mode,omitempty"`
	Privileged      bool              `protobuf:"varint,22,opt,name=privileged,proto3" json:"privileged,omitempty"`
	PublishAllPorts bool              `protobuf:"varint,23,opt,name=publish_all_ports,json=publishAllPorts,proto3" json:"publish_all_ports,omitempty"`
	ReadonlyRootfs  bool              `protobuf:"varint,24,opt,name=readonly_rootfs,json=readonlyRootfs,proto3" json:"readonly_rootfs,omitempty"`
	SecurityOpt     []string          `protobuf:"bytes,25,rep,name=security_opt,json=securityOpt" json:"security_opt,omitempty"`
	StorageOpt      map[string]string `protobuf:"bytes,26,rep,name=storage_opt,json=storageOpt" json:"storage_opt,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Tmpfs           map[string]string `protobuf:"bytes,27,rep,name=tmpfs" json:"tmpfs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	UtsMode         string            `protobuf:"bytes,28,opt,name=uts_mode,json=utsMode,proto3" json:"uts_mode,omitempty"`
	UsernsMode      string            `protobuf:"bytes,29,opt,name=userns_mode,json=usernsMode,proto3" json:"userns_mode,omitempty"`
	ShmSize         int64             `protobuf:"varint,30,opt,name=shm_size,json=shmSize,proto3" json:"shm_size,omitempty"`
	Sysctls         map[string]string `protobuf:"bytes,31,rep,name=sysctls" json:"sysctls,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Runtime         string            `protobuf:"bytes,32,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// Applicable to Windows
	ConsoleSizeHeight uint32 `protobuf:"varint,33,opt,name=console_size_height,json=consoleSizeHeight,proto3" json:"console_size_height,omitempty"`
	ConsoleSizeWidth  uint32 `protobuf:"varint,34,opt,name=console_size_width,json=consoleSizeWidth,proto3" json:"console_size_width,omitempty"`
	Isolation         string `protobuf:"bytes,35,opt,name=isolation,proto3" json:"isolation,omitempty"`
	// Contains container's resources (cgroups, ulimits)
	Resources *Resources `protobuf:"bytes,36,opt,name=resources" json:"resources,omitempty"`
	// Mounts specs used by the container
	Mounts []*VolumeMount `protobuf:"bytes,37,rep,name=mounts" json:"mounts,omitempty"`
	// Run a custom init inside the container, if null, use the daemon's configured settings
	Init bool `protobuf:"varint,38,opt,name=init,proto3" json:"init,omitempty"`
}

func (m *HostConfig) Reset()                    { *m = HostConfig{} }
func (m *HostConfig) String() string            { return proto.CompactTextString(m) }
func (*HostConfig) ProtoMessage()               {}
func (*HostConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

func (m *HostConfig) GetBinds() []string {
	if m != nil {
		return m.Binds
	}
	return nil
}

func (m *HostConfig) GetContainerIdFile() string {
	if m != nil {
		return m.ContainerIdFile
	}
	return ""
}

func (m *HostConfig) GetLogConfig() *LogConfig {
	if m != nil {
		return m.LogConfig
	}
	return nil
}

func (m *HostConfig) GetNetworkMode() string {
	if m != nil {
		return m.NetworkMode
	}
	return ""
}

func (m *HostConfig) GetPortBindings() *PortMap {
	if m != nil {
		return m.PortBindings
	}
	return nil
}

func (m *HostConfig) GetRestartPolicy() *RestartPolicy {
	if m != nil {
		return m.RestartPolicy
	}
	return nil
}

func (m *HostConfig) GetAutoRemove() bool {
	if m != nil {
		return m.AutoRemove
	}
	return false
}

func (m *HostConfig) GetVolumeDriver() string {
	if m != nil {
		return m.VolumeDriver
	}
	return ""
}

func (m *HostConfig) GetVolumesFrom() []string {
	if m != nil {
		return m.VolumesFrom
	}
	return nil
}

func (m *HostConfig) GetCapAdd() []string {
	if m != nil {
		return m.CapAdd
	}
	return nil
}

func (m *HostConfig) GetCapDrop() []string {
	if m != nil {
		return m.CapDrop
	}
	return nil
}

func (m *HostConfig) GetDns() []string {
	if m != nil {
		return m.Dns
	}
	return nil
}

func (m *HostConfig) GetDnsOptions() []string {
	if m != nil {
		return m.DnsOptions
	}
	return nil
}

func (m *HostConfig) GetDnsSearch() []string {
	if m != nil {
		return m.DnsSearch
	}
	return nil
}

func (m *HostConfig) GetExtraHosts() []string {
	if m != nil {
		return m.ExtraHosts
	}
	return nil
}

func (m *HostConfig) GetGroupAdd() []string {
	if m != nil {
		return m.GroupAdd
	}
	return nil
}

func (m *HostConfig) GetIpcMode() string {
	if m != nil {
		return m.IpcMode
	}
	return ""
}

func (m *HostConfig) GetCgroup() string {
	if m != nil {
		return m.Cgroup
	}
	return ""
}

func (m *HostConfig) GetLinks() []string {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *HostConfig) GetOomScoreAdj() int32 {
	if m != nil {
		return m.OomScoreAdj
	}
	return 0
}

func (m *HostConfig) GetPidMode() string {
	if m != nil {
		return m.PidMode
	}
	return ""
}

func (m *HostConfig) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *HostConfig) GetPublishAllPorts() bool {
	if m != nil {
		return m.PublishAllPorts
	}
	return false
}

func (m *HostConfig) GetReadonlyRootfs() bool {
	if m != nil {
		return m.ReadonlyRootfs
	}
	return false
}

func (m *HostConfig) GetSecurityOpt() []string {
	if m != nil {
		return m.SecurityOpt
	}
	return nil
}

func (m *HostConfig) GetStorageOpt() map[string]string {
	if m != nil {
		return m.StorageOpt
	}
	return nil
}

func (m *HostConfig) GetTmpfs() map[string]string {
	if m != nil {
		return m.Tmpfs
	}
	return nil
}

func (m *HostConfig) GetUtsMode() string {
	if m != nil {
		return m.UtsMode
	}
	return ""
}

func (m *HostConfig) GetUsernsMode() string {
	if m != nil {
		return m.UsernsMode
	}
	return ""
}

func (m *HostConfig) GetShmSize() int64 {
	if m != nil {
		return m.ShmSize
	}
	return 0
}

func (m *HostConfig) GetSysctls() map[string]string {
	if m != nil {
		return m.Sysctls
	}
	return nil
}

func (m *HostConfig) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

func (m *HostConfig) GetConsoleSizeHeight() uint32 {
	if m != nil {
		return m.ConsoleSizeHeight
	}
	return 0
}

func (m *HostConfig) GetConsoleSizeWidth() uint32 {
	if m != nil {
		return m.ConsoleSizeWidth
	}
	return 0
}

func (m *HostConfig) GetIsolation() string {
	if m != nil {
		return m.Isolation
	}
	return ""
}

func (m *HostConfig) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *HostConfig) GetMounts() []*VolumeMount {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *HostConfig) GetInit() bool {
	if m != nil {
		return m.Init
	}
	return false
}

// PortBinding represents a binding between a Host IP address and a Host Port
// to see https://github.com/docker/go-connections/blob/master/nat/nat.go
type PortBinding struct {
	// HostIP is the host IP Address
	HostIp   string `protobuf:"bytes,1,opt,name=host_ip,json=hostIp,proto3" json:"host_ip,omitempty"`
	HostPort string `protobuf:"bytes,2,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
}

func (m *PortBinding) Reset()                    { *m = PortBinding{} }
func (m *PortBinding) String() string            { return proto.CompactTextString(m) }
func (*PortBinding) ProtoMessage()               {}
func (*PortBinding) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{7} }

func (m *PortBinding) GetHostIp() string {
	if m != nil {
		return m.HostIp
	}
	return ""
}

func (m *PortBinding) GetHostPort() string {
	if m != nil {
		return m.HostPort
	}
	return ""
}

// PortMap is a collection of PortBinding indexed by Port
// to see https://github.com/docker/go-connections/blob/master/nat/nat.go
type PortMap struct {
	Value map[string]*PortBinding `protobuf:"bytes,1,rep,name=value" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PortMap) Reset()                    { *m = PortMap{} }
func (m *PortMap) String() string            { return proto.CompactTextString(m) }
func (*PortMap) ProtoMessage()               {}
func (*PortMap) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8} }

func (m *PortMap) GetValue() map[string]*PortBinding {
	if m != nil {
		return m.Value
	}
	return nil
}

// PortSet is a collection of structs indexed by Port
// to see https://github.com/docker/go-connections/blob/master/nat/nat.go
type PortSet struct {
	Value map[string]string `protobuf:"bytes,1,rep,name=value" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PortSet) Reset()                    { *m = PortSet{} }
func (m *PortSet) String() string            { return proto.CompactTextString(m) }
func (*PortSet) ProtoMessage()               {}
func (*PortSet) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{9} }

func (m *PortSet) GetValue() map[string]string {
	if m != nil {
		return m.Value
	}
	return nil
}

// Mount represents a mount (volume).
// to see https://github.com/moby/moby/blob/master/api/types/mount/mount.go
type VolumeMount struct {
	MountType string `protobuf:"bytes,1,opt,name=mount_type,json=mountType,proto3" json:"mount_type,omitempty"`
	// Source specifies the name of the mount. Depending on mount type, this
	// may be a volume name or a host path, or even ignored.
	// Source is not supported for tmpfs (must be an empty value)
	Source        string         `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Target        string         `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	ReadOnly      string         `protobuf:"bytes,4,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	Consistency   string         `protobuf:"bytes,5,opt,name=consistency,proto3" json:"consistency,omitempty"`
	BindOptions   *BindOptions   `protobuf:"bytes,6,opt,name=bind_options,json=bindOptions" json:"bind_options,omitempty"`
	VolumeOptions *VolumeOptions `protobuf:"bytes,7,opt,name=volume_options,json=volumeOptions" json:"volume_options,omitempty"`
	TmpfsOptions  *TmpfsOptions  `protobuf:"bytes,8,opt,name=tmpfs_options,json=tmpfsOptions" json:"tmpfs_options,omitempty"`
}

func (m *VolumeMount) Reset()                    { *m = VolumeMount{} }
func (m *VolumeMount) String() string            { return proto.CompactTextString(m) }
func (*VolumeMount) ProtoMessage()               {}
func (*VolumeMount) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{10} }

func (m *VolumeMount) GetMountType() string {
	if m != nil {
		return m.MountType
	}
	return ""
}

func (m *VolumeMount) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *VolumeMount) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *VolumeMount) GetReadOnly() string {
	if m != nil {
		return m.ReadOnly
	}
	return ""
}

func (m *VolumeMount) GetConsistency() string {
	if m != nil {
		return m.Consistency
	}
	return ""
}

func (m *VolumeMount) GetBindOptions() *BindOptions {
	if m != nil {
		return m.BindOptions
	}
	return nil
}

func (m *VolumeMount) GetVolumeOptions() *VolumeOptions {
	if m != nil {
		return m.VolumeOptions
	}
	return nil
}

func (m *VolumeMount) GetTmpfsOptions() *TmpfsOptions {
	if m != nil {
		return m.TmpfsOptions
	}
	return nil
}

// BindOptions defines options specific to mounts of type "bind".
// to see https://github.com/moby/moby/blob/master/api/types/mount/mount.go
type BindOptions struct {
	Propagation string `protobuf:"bytes,1,opt,name=propagation,proto3" json:"propagation,omitempty"`
}

func (m *BindOptions) Reset()                    { *m = BindOptions{} }
func (m *BindOptions) String() string            { return proto.CompactTextString(m) }
func (*BindOptions) ProtoMessage()               {}
func (*BindOptions) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{11} }

func (m *BindOptions) GetPropagation() string {
	if m != nil {
		return m.Propagation
	}
	return ""
}

// VolumeOptions represents the options for a mount of type volume.
type VolumeOptions struct {
	NoCopy bool              `protobuf:"varint,1,opt,name=no_copy,json=noCopy,proto3" json:"no_copy,omitempty"`
	Labels map[string]string `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Driver *DriverConfig     `protobuf:"bytes,3,opt,name=driver" json:"driver,omitempty"`
}

func (m *VolumeOptions) Reset()                    { *m = VolumeOptions{} }
func (m *VolumeOptions) String() string            { return proto.CompactTextString(m) }
func (*VolumeOptions) ProtoMessage()               {}
func (*VolumeOptions) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{12} }

func (m *VolumeOptions) GetNoCopy() bool {
	if m != nil {
		return m.NoCopy
	}
	return false
}

func (m *VolumeOptions) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *VolumeOptions) GetDriver() *DriverConfig {
	if m != nil {
		return m.Driver
	}
	return nil
}

// Driver represents a volume driver.
type DriverConfig struct {
	Name    string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Options map[string]string `protobuf:"bytes,2,rep,name=options" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DriverConfig) Reset()                    { *m = DriverConfig{} }
func (m *DriverConfig) String() string            { return proto.CompactTextString(m) }
func (*DriverConfig) ProtoMessage()               {}
func (*DriverConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{13} }

func (m *DriverConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DriverConfig) GetOptions() map[string]string {
	if m != nil {
		return m.Options
	}
	return nil
}

// TmpfsOptions defines options specific to mounts of type "tmpfs".
type TmpfsOptions struct {
	// Size sets the size of the tmpfs, in bytes.
	//
	// This will be converted to an operating system specific value
	// depending on the host. For example, on linux, it will be converted to
	// use a 'k', 'm' or 'g' syntax. BSD, though not widely supported with
	// docker, uses a straight byte value.
	//
	// Percentages are not supported.
	SizeBytes int64 `protobuf:"varint,1,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// Mode of the tmpfs upon creation
	Mode uint32 `protobuf:"varint,2,opt,name=mode,proto3" json:"mode,omitempty"`
}

func (m *TmpfsOptions) Reset()                    { *m = TmpfsOptions{} }
func (m *TmpfsOptions) String() string            { return proto.CompactTextString(m) }
func (*TmpfsOptions) ProtoMessage()               {}
func (*TmpfsOptions) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{14} }

func (m *TmpfsOptions) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *TmpfsOptions) GetMode() uint32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

// WeightDevice is a structure that holds device:weight pair
// to see http://github.com/moby/moby/blob/master/api/types/blkiodev/blkio.go
type WeightDevice struct {
	Path   string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Weight int32  `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *WeightDevice) Reset()                    { *m = WeightDevice{} }
func (m *WeightDevice) String() string            { return proto.CompactTextString(m) }
func (*WeightDevice) ProtoMessage()               {}
func (*WeightDevice) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{15} }

func (m *WeightDevice) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *WeightDevice) GetWeight() int32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// ThrottleDevice is a structure that holds device:rate_per_second pair
// to see http://github.com/moby/moby/blob/master/api/types/blkiodev/blkio.go
type ThrottleDevice struct {
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Rate uint64 `protobuf:"varint,2,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *ThrottleDevice) Reset()                    { *m = ThrottleDevice{} }
func (m *ThrottleDevice) String() string            { return proto.CompactTextString(m) }
func (*ThrottleDevice) ProtoMessage()               {}
func (*ThrottleDevice) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{16} }

func (m *ThrottleDevice) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ThrottleDevice) GetRate() uint64 {
	if m != nil {
		return m.Rate
	}
	return 0
}

// Ulimit is a human friendly version of Rlimit.
// to see https://github.com/docker/go-units/blob/master/ulimit.go
type Ulimit struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Hard int64  `protobuf:"varint,2,opt,name=hard,proto3" json:"hard,omitempty"`
	Soft int64  `protobuf:"varint,3,opt,name=soft,proto3" json:"soft,omitempty"`
}

func (m *Ulimit) Reset()                    { *m = Ulimit{} }
func (m *Ulimit) String() string            { return proto.CompactTextString(m) }
func (*Ulimit) ProtoMessage()               {}
func (*Ulimit) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{17} }

func (m *Ulimit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Ulimit) GetHard() int64 {
	if m != nil {
		return m.Hard
	}
	return 0
}

func (m *Ulimit) GetSoft() int64 {
	if m != nil {
		return m.Soft
	}
	return 0
}

// NetworkingConfig represents the container's networking configuration for each of its interfaces
// Carries the networking configs specified in the 'docker run' and 'docker network connect' commands
// to see https://github.com/moby/moby/blob/master/api/types/network/network.go
type NetworkingConfig struct {
	EndpointsConfig map[string]*EndpointSettings `protobuf:"bytes,1,rep,name=endpoints_config,json=endpointsConfig" json:"endpoints_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NetworkingConfig) Reset()                    { *m = NetworkingConfig{} }
func (m *NetworkingConfig) String() string            { return proto.CompactTextString(m) }
func (*NetworkingConfig) ProtoMessage()               {}
func (*NetworkingConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{18} }

func (m *NetworkingConfig) GetEndpointsConfig() map[string]*EndpointSettings {
	if m != nil {
		return m.EndpointsConfig
	}
	return nil
}

// EndpointSettings stores the network endpoint details
type EndpointSettings struct {
	// Configurations
	IpamConfig *EndpointIPAMConfig `protobuf:"bytes,1,opt,name=ipam_config,json=ipamConfig" json:"ipam_config,omitempty"`
	Links      []string            `protobuf:"bytes,2,rep,name=links" json:"links,omitempty"`
	Aliases    []string            `protobuf:"bytes,3,rep,name=aliases" json:"aliases,omitempty"`
	// Operational data
	NetworkId           string            `protobuf:"bytes,4,opt,name=network_id,json=networkId,proto3" json:"network_id,omitempty"`
	EndpointId          string            `protobuf:"bytes,5,opt,name=endpoint_id,json=endpointId,proto3" json:"endpoint_id,omitempty"`
	Gateway             string            `protobuf:"bytes,6,opt,name=gateway,proto3" json:"gateway,omitempty"`
	IpAddress           string            `protobuf:"bytes,7,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	IpPrefixLen         int32             `protobuf:"varint,8,opt,name=ip_prefix_len,json=ipPrefixLen,proto3" json:"ip_prefix_len,omitempty"`
	Ipv6Gateway         string            `protobuf:"bytes,9,opt,name=ipv6_gateway,json=ipv6Gateway,proto3" json:"ipv6_gateway,omitempty"`
	GlobalIpv6Address   string            `protobuf:"bytes,10,opt,name=global_ipv6_address,json=globalIpv6Address,proto3" json:"global_ipv6_address,omitempty"`
	GlobalIpv6PrefixLen int32             `protobuf:"varint,11,opt,name=global_ipv6_prefix_len,json=globalIpv6PrefixLen,proto3" json:"global_ipv6_prefix_len,omitempty"`
	MacAddress          string            `protobuf:"bytes,12,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	DriverOpts          map[string]string `protobuf:"bytes,13,rep,name=driver_opts,json=driverOpts" json:"driver_opts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EndpointSettings) Reset()                    { *m = EndpointSettings{} }
func (m *EndpointSettings) String() string            { return proto.CompactTextString(m) }
func (*EndpointSettings) ProtoMessage()               {}
func (*EndpointSettings) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{19} }

func (m *EndpointSettings) GetIpamConfig() *EndpointIPAMConfig {
	if m != nil {
		return m.IpamConfig
	}
	return nil
}

func (m *EndpointSettings) GetLinks() []string {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *EndpointSettings) GetAliases() []string {
	if m != nil {
		return m.Aliases
	}
	return nil
}

func (m *EndpointSettings) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *EndpointSettings) GetEndpointId() string {
	if m != nil {
		return m.EndpointId
	}
	return ""
}

func (m *EndpointSettings) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *EndpointSettings) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *EndpointSettings) GetIpPrefixLen() int32 {
	if m != nil {
		return m.IpPrefixLen
	}
	return 0
}

func (m *EndpointSettings) GetIpv6Gateway() string {
	if m != nil {
		return m.Ipv6Gateway
	}
	return ""
}

func (m *EndpointSettings) GetGlobalIpv6Address() string {
	if m != nil {
		return m.GlobalIpv6Address
	}
	return ""
}

func (m *EndpointSettings) GetGlobalIpv6PrefixLen() int32 {
	if m != nil {
		return m.GlobalIpv6PrefixLen
	}
	return 0
}

func (m *EndpointSettings) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *EndpointSettings) GetDriverOpts() map[string]string {
	if m != nil {
		return m.DriverOpts
	}
	return nil
}

// EndpointIPAMConfig represents IPAM configurations for the endpoint
type EndpointIPAMConfig struct {
	Ipv4Address  string   `protobuf:"bytes,1,opt,name=ipv4_address,json=ipv4Address,proto3" json:"ipv4_address,omitempty"`
	Ipv6Address  string   `protobuf:"bytes,2,opt,name=ipv6_address,json=ipv6Address,proto3" json:"ipv6_address,omitempty"`
	LinkLocalIps []string `protobuf:"bytes,3,rep,name=link_local_ips,json=linkLocalIps" json:"link_local_ips,omitempty"`
}

func (m *EndpointIPAMConfig) Reset()                    { *m = EndpointIPAMConfig{} }
func (m *EndpointIPAMConfig) String() string            { return proto.CompactTextString(m) }
func (*EndpointIPAMConfig) ProtoMessage()               {}
func (*EndpointIPAMConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{20} }

func (m *EndpointIPAMConfig) GetIpv4Address() string {
	if m != nil {
		return m.Ipv4Address
	}
	return ""
}

func (m *EndpointIPAMConfig) GetIpv6Address() string {
	if m != nil {
		return m.Ipv6Address
	}
	return ""
}

func (m *EndpointIPAMConfig) GetLinkLocalIps() []string {
	if m != nil {
		return m.LinkLocalIps
	}
	return nil
}

func init() {
	proto.RegisterType((*HealthConfig)(nil), "moby.HealthConfig")
	proto.RegisterType((*Config)(nil), "moby.Config")
	proto.RegisterType((*LogConfig)(nil), "moby.LogConfig")
	proto.RegisterType((*RestartPolicy)(nil), "moby.RestartPolicy")
	proto.RegisterType((*Resources)(nil), "moby.Resources")
	proto.RegisterType((*DeviceMapping)(nil), "moby.DeviceMapping")
	proto.RegisterType((*HostConfig)(nil), "moby.HostConfig")
	proto.RegisterType((*PortBinding)(nil), "moby.PortBinding")
	proto.RegisterType((*PortMap)(nil), "moby.PortMap")
	proto.RegisterType((*PortSet)(nil), "moby.PortSet")
	proto.RegisterType((*VolumeMount)(nil), "moby.VolumeMount")
	proto.RegisterType((*BindOptions)(nil), "moby.BindOptions")
	proto.RegisterType((*VolumeOptions)(nil), "moby.VolumeOptions")
	proto.RegisterType((*DriverConfig)(nil), "moby.DriverConfig")
	proto.RegisterType((*TmpfsOptions)(nil), "moby.TmpfsOptions")
	proto.RegisterType((*WeightDevice)(nil), "moby.WeightDevice")
	proto.RegisterType((*ThrottleDevice)(nil), "moby.ThrottleDevice")
	proto.RegisterType((*Ulimit)(nil), "moby.Ulimit")
	proto.RegisterType((*NetworkingConfig)(nil), "moby.NetworkingConfig")
	proto.RegisterType((*EndpointSettings)(nil), "moby.EndpointSettings")
	proto.RegisterType((*EndpointIPAMConfig)(nil), "moby.EndpointIPAMConfig")
}
func (m *HealthConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Test) > 0 {
		for _, s := range m.Test {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IntervalSeconds != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IntervalSeconds))
	}
	if m.TimeoutSeconds != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TimeoutSeconds))
	}
	if m.StartPeriod != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StartPeriod))
	}
	if m.Retries != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Retries))
	}
	return i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hostname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.Domainname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Domainname)))
		i += copy(dAtA[i:], m.Domainname)
	}
	if len(m.User) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.AttachStdin {
		dAtA[i] = 0x20
		i++
		if m.AttachStdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AttachStdout {
		dAtA[i] = 0x28
		i++
		if m.AttachStdout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AttachStderr {
		dAtA[i] = 0x30
		i++
		if m.AttachStderr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExposedPorts != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ExposedPorts.Size()))
		n1, err := m.ExposedPorts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Tty {
		dAtA[i] = 0x40
		i++
		if m.Tty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OpenStdin {
		dAtA[i] = 0x48
		i++
		if m.OpenStdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StdinOnce {
		dAtA[i] = 0x50
		i++
		if m.StdinOnce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Healthcheck != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Healthcheck.Size()))
		n2, err := m.Healthcheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.ArgsEscaped {
		dAtA[i] = 0x70
		i++
		if m.ArgsEscaped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Volumes) > 0 {
		for k, _ := range m.Volumes {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			v := m.Volumes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if len(m.WorkingDir) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.WorkingDir)))
		i += copy(dAtA[i:], m.WorkingDir)
	}
	if len(m.Entrypoint) > 0 {
		for _, s := range m.Entrypoint {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.NetworkDisabled {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.NetworkDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.OnBuild) > 0 {
		for _, s := range m.OnBuild {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.StopSignal) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.StopSignal)))
		i += copy(dAtA[i:], m.StopSignal)
	}
	if m.StopTimeout != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StopTimeout))
	}
	if len(m.Shell) > 0 {
		for _, s := range m.Shell {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *LogConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ConfigType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ConfigType)))
		i += copy(dAtA[i:], m.ConfigType)
	}
	if len(m.Config) > 0 {
		for k, _ := range m.Config {
			dAtA[i] = 0x12
			i++
			v := m.Config[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *RestartPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestartPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.MaximumRetryCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MaximumRetryCount))
	}
	return i, nil
}

func (m *Resources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resources) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CpuShares != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuShares))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Memory))
	}
	if m.NanoCpus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NanoCpus))
	}
	if len(m.CgroupParent) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CgroupParent)))
		i += copy(dAtA[i:], m.CgroupParent)
	}
	if m.BlkioWeight != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BlkioWeight))
	}
	if m.BlkioWeightDevice != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BlkioWeightDevice.Size()))
		n4, err := m.BlkioWeightDevice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.BlkioDeviceReadBps != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BlkioDeviceReadBps.Size()))
		n5, err := m.BlkioDeviceReadBps.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.BlkioDeviceWriteBps != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BlkioDeviceWriteBps.Size()))
		n6, err := m.BlkioDeviceWriteBps.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.BlkioDeviceReadIops != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BlkioDeviceReadIops.Size()))
		n7, err := m.BlkioDeviceReadIops.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.BlkioDeviceWriteIops != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BlkioDeviceWriteIops.Size()))
		n8, err := m.BlkioDeviceWriteIops.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.CpuPeriod != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuPeriod))
	}
	if m.CpuQuota != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuQuota))
	}
	if m.CpuRealtimePeriod != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuRealtimePeriod))
	}
	if m.CpuRealtimeRuntime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuRealtimeRuntime))
	}
	if len(m.CpusetCpus) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CpusetCpus)))
		i += copy(dAtA[i:], m.CpusetCpus)
	}
	if len(m.CpusetMems) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CpusetMems)))
		i += copy(dAtA[i:], m.CpusetMems)
	}
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DeviceCgroupRules) > 0 {
		for _, s := range m.DeviceCgroupRules {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DiskQuota != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DiskQuota))
	}
	if m.KernelMemory != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.KernelMemory))
	}
	if m.MemoryReservation != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MemoryReservation))
	}
	if m.MemorySwap != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MemorySwap))
	}
	if m.MemorySwappiness != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MemorySwappiness))
	}
	if m.OomKillDisable != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OomKillDisable))
	}
	if m.PidsLimit != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PidsLimit))
	}
	if len(m.Ulimits) > 0 {
		for _, msg := range m.Ulimits {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CpuCount != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuCount))
	}
	if m.CpuPercent != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuPercent))
	}
	if m.IoMaximumIops != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IoMaximumIops))
	}
	if m.IoMaximumBandwidth != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IoMaximumBandwidth))
	}
	return i, nil
}

func (m *DeviceMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PathOnHost) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PathOnHost)))
		i += copy(dAtA[i:], m.PathOnHost)
	}
	if len(m.PathInContainer) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PathInContainer)))
		i += copy(dAtA[i:], m.PathInContainer)
	}
	if len(m.CgroupPermissions) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CgroupPermissions)))
		i += copy(dAtA[i:], m.CgroupPermissions)
	}
	return i, nil
}

func (m *HostConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Binds) > 0 {
		for _, s := range m.Binds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ContainerIdFile) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ContainerIdFile)))
		i += copy(dAtA[i:], m.ContainerIdFile)
	}
	if m.LogConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LogConfig.Size()))
		n9, err := m.LogConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.NetworkMode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.NetworkMode)))
		i += copy(dAtA[i:], m.NetworkMode)
	}
	if m.PortBindings != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PortBindings.Size()))
		n10, err := m.PortBindings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.RestartPolicy != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RestartPolicy.Size()))
		n11, err := m.RestartPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.AutoRemove {
		dAtA[i] = 0x38
		i++
		if m.AutoRemove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VolumeDriver) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.VolumeDriver)))
		i += copy(dAtA[i:], m.VolumeDriver)
	}
	if len(m.VolumesFrom) > 0 {
		for _, s := range m.VolumesFrom {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CapAdd) > 0 {
		for _, s := range m.CapAdd {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CapDrop) > 0 {
		for _, s := range m.CapDrop {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Dns) > 0 {
		for _, s := range m.Dns {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DnsOptions) > 0 {
		for _, s := range m.DnsOptions {
			dAtA[i] = 0x6a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DnsSearch) > 0 {
		for _, s := range m.DnsSearch {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExtraHosts) > 0 {
		for _, s := range m.ExtraHosts {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.GroupAdd) > 0 {
		for _, s := range m.GroupAdd {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.IpcMode) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IpcMode)))
		i += copy(dAtA[i:], m.IpcMode)
	}
	if len(m.Cgroup) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Cgroup)))
		i += copy(dAtA[i:], m.Cgroup)
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.OomScoreAdj != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OomScoreAdj))
	}
	if len(m.PidMode) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PidMode)))
		i += copy(dAtA[i:], m.PidMode)
	}
	if m.Privileged {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PublishAllPorts {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.PublishAllPorts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReadonlyRootfs {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.ReadonlyRootfs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.SecurityOpt) > 0 {
		for _, s := range m.SecurityOpt {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.StorageOpt) > 0 {
		for k, _ := range m.StorageOpt {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			v := m.StorageOpt[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Tmpfs) > 0 {
		for k, _ := range m.Tmpfs {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			v := m.Tmpfs[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.UtsMode) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.UtsMode)))
		i += copy(dAtA[i:], m.UtsMode)
	}
	if len(m.UsernsMode) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.UsernsMode)))
		i += copy(dAtA[i:], m.UsernsMode)
	}
	if m.ShmSize != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ShmSize))
	}
	if len(m.Sysctls) > 0 {
		for k, _ := range m.Sysctls {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			v := m.Sysctls[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Runtime) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Runtime)))
		i += copy(dAtA[i:], m.Runtime)
	}
	if m.ConsoleSizeHeight != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ConsoleSizeHeight))
	}
	if m.ConsoleSizeWidth != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ConsoleSizeWidth))
	}
	if len(m.Isolation) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Isolation)))
		i += copy(dAtA[i:], m.Isolation)
	}
	if m.Resources != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Resources.Size()))
		n12, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Mounts) > 0 {
		for _, msg := range m.Mounts {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Init {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		if m.Init {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PortBinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortBinding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostIp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.HostIp)))
		i += copy(dAtA[i:], m.HostIp)
	}
	if len(m.HostPort) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.HostPort)))
		i += copy(dAtA[i:], m.HostPort)
	}
	return i, nil
}

func (m *PortMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, _ := range m.Value {
			dAtA[i] = 0xa
			i++
			v := m.Value[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n13, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	return i, nil
}

func (m *PortSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, _ := range m.Value {
			dAtA[i] = 0xa
			i++
			v := m.Value[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *VolumeMount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeMount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MountType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MountType)))
		i += copy(dAtA[i:], m.MountType)
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Target) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if len(m.ReadOnly) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ReadOnly)))
		i += copy(dAtA[i:], m.ReadOnly)
	}
	if len(m.Consistency) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Consistency)))
		i += copy(dAtA[i:], m.Consistency)
	}
	if m.BindOptions != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BindOptions.Size()))
		n14, err := m.BindOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.VolumeOptions != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VolumeOptions.Size()))
		n15, err := m.VolumeOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.TmpfsOptions != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TmpfsOptions.Size()))
		n16, err := m.TmpfsOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *BindOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BindOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Propagation) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Propagation)))
		i += copy(dAtA[i:], m.Propagation)
	}
	return i, nil
}

func (m *VolumeOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NoCopy {
		dAtA[i] = 0x8
		i++
		if m.NoCopy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x12
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Driver != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Driver.Size()))
		n17, err := m.Driver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *DriverConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DriverConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Options) > 0 {
		for k, _ := range m.Options {
			dAtA[i] = 0x12
			i++
			v := m.Options[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *TmpfsOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TmpfsOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SizeBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SizeBytes))
	}
	if m.Mode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mode))
	}
	return i, nil
}

func (m *WeightDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Weight))
	}
	return i, nil
}

func (m *ThrottleDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThrottleDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Rate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rate))
	}
	return i, nil
}

func (m *Ulimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ulimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Hard != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Hard))
	}
	if m.Soft != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Soft))
	}
	return i, nil
}

func (m *NetworkingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkingConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EndpointsConfig) > 0 {
		for k, _ := range m.EndpointsConfig {
			dAtA[i] = 0xa
			i++
			v := m.EndpointsConfig[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n18, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n18
			}
		}
	}
	return i, nil
}

func (m *EndpointSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpamConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IpamConfig.Size()))
		n19, err := m.IpamConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Aliases) > 0 {
		for _, s := range m.Aliases {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.NetworkId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.NetworkId)))
		i += copy(dAtA[i:], m.NetworkId)
	}
	if len(m.EndpointId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndpointId)))
		i += copy(dAtA[i:], m.EndpointId)
	}
	if len(m.Gateway) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Gateway)))
		i += copy(dAtA[i:], m.Gateway)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if m.IpPrefixLen != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IpPrefixLen))
	}
	if len(m.Ipv6Gateway) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ipv6Gateway)))
		i += copy(dAtA[i:], m.Ipv6Gateway)
	}
	if len(m.GlobalIpv6Address) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.GlobalIpv6Address)))
		i += copy(dAtA[i:], m.GlobalIpv6Address)
	}
	if m.GlobalIpv6PrefixLen != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GlobalIpv6PrefixLen))
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.DriverOpts) > 0 {
		for k, _ := range m.DriverOpts {
			dAtA[i] = 0x6a
			i++
			v := m.DriverOpts[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *EndpointIPAMConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointIPAMConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ipv4Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ipv4Address)))
		i += copy(dAtA[i:], m.Ipv4Address)
	}
	if len(m.Ipv6Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ipv6Address)))
		i += copy(dAtA[i:], m.Ipv6Address)
	}
	if len(m.LinkLocalIps) > 0 {
		for _, s := range m.LinkLocalIps {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeFixed64Api(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Api(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HealthConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.Test) > 0 {
		for _, s := range m.Test {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.IntervalSeconds != 0 {
		n += 1 + sovApi(uint64(m.IntervalSeconds))
	}
	if m.TimeoutSeconds != 0 {
		n += 1 + sovApi(uint64(m.TimeoutSeconds))
	}
	if m.StartPeriod != 0 {
		n += 1 + sovApi(uint64(m.StartPeriod))
	}
	if m.Retries != 0 {
		n += 1 + sovApi(uint64(m.Retries))
	}
	return n
}

func (m *Config) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Domainname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AttachStdin {
		n += 2
	}
	if m.AttachStdout {
		n += 2
	}
	if m.AttachStderr {
		n += 2
	}
	if m.ExposedPorts != nil {
		l = m.ExposedPorts.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Tty {
		n += 2
	}
	if m.OpenStdin {
		n += 2
	}
	if m.StdinOnce {
		n += 2
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Healthcheck != nil {
		l = m.Healthcheck.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ArgsEscaped {
		n += 2
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Volumes) > 0 {
		for k, v := range m.Volumes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.WorkingDir)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.Entrypoint) > 0 {
		for _, s := range m.Entrypoint {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.NetworkDisabled {
		n += 3
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.OnBuild) > 0 {
		for _, s := range m.OnBuild {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.StopSignal)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.StopTimeout != 0 {
		n += 2 + sovApi(uint64(m.StopTimeout))
	}
	if len(m.Shell) > 0 {
		for _, s := range m.Shell {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *LogConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.ConfigType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Config) > 0 {
		for k, v := range m.Config {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RestartPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MaximumRetryCount != 0 {
		n += 1 + sovApi(uint64(m.MaximumRetryCount))
	}
	return n
}

func (m *Resources) Size() (n int) {
	var l int
	_ = l
	if m.CpuShares != 0 {
		n += 1 + sovApi(uint64(m.CpuShares))
	}
	if m.Memory != 0 {
		n += 1 + sovApi(uint64(m.Memory))
	}
	if m.NanoCpus != 0 {
		n += 1 + sovApi(uint64(m.NanoCpus))
	}
	l = len(m.CgroupParent)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BlkioWeight != 0 {
		n += 1 + sovApi(uint64(m.BlkioWeight))
	}
	if m.BlkioWeightDevice != nil {
		l = m.BlkioWeightDevice.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BlkioDeviceReadBps != nil {
		l = m.BlkioDeviceReadBps.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BlkioDeviceWriteBps != nil {
		l = m.BlkioDeviceWriteBps.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BlkioDeviceReadIops != nil {
		l = m.BlkioDeviceReadIops.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BlkioDeviceWriteIops != nil {
		l = m.BlkioDeviceWriteIops.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CpuPeriod != 0 {
		n += 1 + sovApi(uint64(m.CpuPeriod))
	}
	if m.CpuQuota != 0 {
		n += 1 + sovApi(uint64(m.CpuQuota))
	}
	if m.CpuRealtimePeriod != 0 {
		n += 1 + sovApi(uint64(m.CpuRealtimePeriod))
	}
	if m.CpuRealtimeRuntime != 0 {
		n += 1 + sovApi(uint64(m.CpuRealtimeRuntime))
	}
	l = len(m.CpusetCpus)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.CpusetMems)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if len(m.DeviceCgroupRules) > 0 {
		for _, s := range m.DeviceCgroupRules {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.DiskQuota != 0 {
		n += 2 + sovApi(uint64(m.DiskQuota))
	}
	if m.KernelMemory != 0 {
		n += 2 + sovApi(uint64(m.KernelMemory))
	}
	if m.MemoryReservation != 0 {
		n += 2 + sovApi(uint64(m.MemoryReservation))
	}
	if m.MemorySwap != 0 {
		n += 2 + sovApi(uint64(m.MemorySwap))
	}
	if m.MemorySwappiness != 0 {
		n += 2 + sovApi(uint64(m.MemorySwappiness))
	}
	if m.OomKillDisable != 0 {
		n += 2 + sovApi(uint64(m.OomKillDisable))
	}
	if m.PidsLimit != 0 {
		n += 2 + sovApi(uint64(m.PidsLimit))
	}
	if len(m.Ulimits) > 0 {
		for _, e := range m.Ulimits {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.CpuCount != 0 {
		n += 2 + sovApi(uint64(m.CpuCount))
	}
	if m.CpuPercent != 0 {
		n += 2 + sovApi(uint64(m.CpuPercent))
	}
	if m.IoMaximumIops != 0 {
		n += 2 + sovApi(uint64(m.IoMaximumIops))
	}
	if m.IoMaximumBandwidth != 0 {
		n += 2 + sovApi(uint64(m.IoMaximumBandwidth))
	}
	return n
}

func (m *DeviceMapping) Size() (n int) {
	var l int
	_ = l
	l = len(m.PathOnHost)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.PathInContainer)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.CgroupPermissions)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *HostConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.Binds) > 0 {
		for _, s := range m.Binds {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.ContainerIdFile)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.LogConfig != nil {
		l = m.LogConfig.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.NetworkMode)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PortBindings != nil {
		l = m.PortBindings.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RestartPolicy != nil {
		l = m.RestartPolicy.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AutoRemove {
		n += 2
	}
	l = len(m.VolumeDriver)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.VolumesFrom) > 0 {
		for _, s := range m.VolumesFrom {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.CapAdd) > 0 {
		for _, s := range m.CapAdd {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.CapDrop) > 0 {
		for _, s := range m.CapDrop {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Dns) > 0 {
		for _, s := range m.Dns {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.DnsOptions) > 0 {
		for _, s := range m.DnsOptions {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.DnsSearch) > 0 {
		for _, s := range m.DnsSearch {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.ExtraHosts) > 0 {
		for _, s := range m.ExtraHosts {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.GroupAdd) > 0 {
		for _, s := range m.GroupAdd {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	l = len(m.IpcMode)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.Cgroup)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.OomScoreAdj != 0 {
		n += 2 + sovApi(uint64(m.OomScoreAdj))
	}
	l = len(m.PidMode)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Privileged {
		n += 3
	}
	if m.PublishAllPorts {
		n += 3
	}
	if m.ReadonlyRootfs {
		n += 3
	}
	if len(m.SecurityOpt) > 0 {
		for _, s := range m.SecurityOpt {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if len(m.StorageOpt) > 0 {
		for k, v := range m.StorageOpt {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.Tmpfs) > 0 {
		for k, v := range m.Tmpfs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.UtsMode)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.UsernsMode)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.ShmSize != 0 {
		n += 2 + sovApi(uint64(m.ShmSize))
	}
	if len(m.Sysctls) > 0 {
		for k, v := range m.Sysctls {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.Runtime)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.ConsoleSizeHeight != 0 {
		n += 2 + sovApi(uint64(m.ConsoleSizeHeight))
	}
	if m.ConsoleSizeWidth != 0 {
		n += 2 + sovApi(uint64(m.ConsoleSizeWidth))
	}
	l = len(m.Isolation)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.Mounts) > 0 {
		for _, e := range m.Mounts {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.Init {
		n += 3
	}
	return n
}

func (m *PortBinding) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostIp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.HostPort)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *PortMap) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, v := range m.Value {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PortSet) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, v := range m.Value {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VolumeMount) Size() (n int) {
	var l int
	_ = l
	l = len(m.MountType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ReadOnly)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Consistency)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BindOptions != nil {
		l = m.BindOptions.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.VolumeOptions != nil {
		l = m.VolumeOptions.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TmpfsOptions != nil {
		l = m.TmpfsOptions.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *BindOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Propagation)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *VolumeOptions) Size() (n int) {
	var l int
	_ = l
	if m.NoCopy {
		n += 2
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.Driver != nil {
		l = m.Driver.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DriverConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Options) > 0 {
		for k, v := range m.Options {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TmpfsOptions) Size() (n int) {
	var l int
	_ = l
	if m.SizeBytes != 0 {
		n += 1 + sovApi(uint64(m.SizeBytes))
	}
	if m.Mode != 0 {
		n += 1 + sovApi(uint64(m.Mode))
	}
	return n
}

func (m *WeightDevice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovApi(uint64(m.Weight))
	}
	return n
}

func (m *ThrottleDevice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Rate != 0 {
		n += 1 + sovApi(uint64(m.Rate))
	}
	return n
}

func (m *Ulimit) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Hard != 0 {
		n += 1 + sovApi(uint64(m.Hard))
	}
	if m.Soft != 0 {
		n += 1 + sovApi(uint64(m.Soft))
	}
	return n
}

func (m *NetworkingConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.EndpointsConfig) > 0 {
		for k, v := range m.EndpointsConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EndpointSettings) Size() (n int) {
	var l int
	_ = l
	if m.IpamConfig != nil {
		l = m.IpamConfig.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Aliases) > 0 {
		for _, s := range m.Aliases {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndpointId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IpPrefixLen != 0 {
		n += 1 + sovApi(uint64(m.IpPrefixLen))
	}
	l = len(m.Ipv6Gateway)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GlobalIpv6Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GlobalIpv6PrefixLen != 0 {
		n += 1 + sovApi(uint64(m.GlobalIpv6PrefixLen))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.DriverOpts) > 0 {
		for k, v := range m.DriverOpts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EndpointIPAMConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ipv4Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Ipv6Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.LinkLocalIps) > 0 {
		for _, s := range m.LinkLocalIps {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HealthConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Test = append(m.Test, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSeconds", wireType)
			}
			m.IntervalSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSeconds", wireType)
			}
			m.TimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPeriod", wireType)
			}
			m.StartPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domainname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domainname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachStdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttachStdin = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachStdout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttachStdout = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachStderr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttachStderr = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposedPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExposedPorts == nil {
				m.ExposedPorts = &PortSet{}
			}
			if err := m.ExposedPorts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenStdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OpenStdin = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdinOnce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StdinOnce = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Healthcheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Healthcheck == nil {
				m.Healthcheck = &HealthConfig{}
			}
			if err := m.Healthcheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsEscaped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArgsEscaped = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Volumes == nil {
				m.Volumes = make(map[string]*VolumeMount)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VolumeMount{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Volumes[mapkey] = mapvalue
			} else {
				var mapvalue *VolumeMount
				m.Volumes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entrypoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entrypoint = append(m.Entrypoint, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetworkDisabled = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnBuild", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnBuild = append(m.OnBuild, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Labels[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Labels[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopSignal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StopSignal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopTimeout", wireType)
			}
			m.StopTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopTimeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shell", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shell = append(m.Shell, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Config == nil {
				m.Config = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Config[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Config[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestartPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestartPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestartPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumRetryCount", wireType)
			}
			m.MaximumRetryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumRetryCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuShares", wireType)
			}
			m.CpuShares = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuShares |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NanoCpus", wireType)
			}
			m.NanoCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NanoCpus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgroupParent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgroupParent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioWeight", wireType)
			}
			m.BlkioWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlkioWeight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioWeightDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlkioWeightDevice == nil {
				m.BlkioWeightDevice = &WeightDevice{}
			}
			if err := m.BlkioWeightDevice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceReadBps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlkioDeviceReadBps == nil {
				m.BlkioDeviceReadBps = &ThrottleDevice{}
			}
			if err := m.BlkioDeviceReadBps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceWriteBps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlkioDeviceWriteBps == nil {
				m.BlkioDeviceWriteBps = &ThrottleDevice{}
			}
			if err := m.BlkioDeviceWriteBps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceReadIops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlkioDeviceReadIops == nil {
				m.BlkioDeviceReadIops = &ThrottleDevice{}
			}
			if err := m.BlkioDeviceReadIops.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceWriteIops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlkioDeviceWriteIops == nil {
				m.BlkioDeviceWriteIops = &ThrottleDevice{}
			}
			if err := m.BlkioDeviceWriteIops.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPeriod", wireType)
			}
			m.CpuPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuPeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuQuota", wireType)
			}
			m.CpuQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuQuota |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuRealtimePeriod", wireType)
			}
			m.CpuRealtimePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuRealtimePeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuRealtimeRuntime", wireType)
			}
			m.CpuRealtimeRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuRealtimeRuntime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpusetCpus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpusetCpus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpusetMems", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpusetMems = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DeviceMapping{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCgroupRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceCgroupRules = append(m.DeviceCgroupRules, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskQuota", wireType)
			}
			m.DiskQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskQuota |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelMemory", wireType)
			}
			m.KernelMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryReservation", wireType)
			}
			m.MemoryReservation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryReservation |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySwap", wireType)
			}
			m.MemorySwap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySwap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySwappiness", wireType)
			}
			m.MemorySwappiness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySwappiness |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OomKillDisable", wireType)
			}
			m.OomKillDisable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OomKillDisable |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PidsLimit", wireType)
			}
			m.PidsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PidsLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ulimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ulimits = append(m.Ulimits, &Ulimit{})
			if err := m.Ulimits[len(m.Ulimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCount", wireType)
			}
			m.CpuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPercent", wireType)
			}
			m.CpuPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuPercent |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoMaximumIops", wireType)
			}
			m.IoMaximumIops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoMaximumIops |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoMaximumBandwidth", wireType)
			}
			m.IoMaximumBandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoMaximumBandwidth |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathOnHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathOnHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathInContainer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathInContainer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgroupPermissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgroupPermissions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Binds = append(m.Binds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerIdFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerIdFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogConfig == nil {
				m.LogConfig = &LogConfig{}
			}
			if err := m.LogConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortBindings == nil {
				m.PortBindings = &PortMap{}
			}
			if err := m.PortBindings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RestartPolicy == nil {
				m.RestartPolicy = &RestartPolicy{}
			}
			if err := m.RestartPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRemove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRemove = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeDriver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeDriver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumesFrom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumesFrom = append(m.VolumesFrom, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapAdd = append(m.CapAdd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapDrop = append(m.CapDrop, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dns = append(m.Dns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsOptions = append(m.DnsOptions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsSearch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsSearch = append(m.DnsSearch, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraHosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraHosts = append(m.ExtraHosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAdd = append(m.GroupAdd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpcMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpcMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cgroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cgroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OomScoreAdj", wireType)
			}
			m.OomScoreAdj = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OomScoreAdj |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PidMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PidMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishAllPorts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublishAllPorts = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadonlyRootfs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadonlyRootfs = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityOpt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityOpt = append(m.SecurityOpt, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageOpt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.StorageOpt == nil {
				m.StorageOpt = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.StorageOpt[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.StorageOpt[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tmpfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Tmpfs == nil {
				m.Tmpfs = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Tmpfs[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Tmpfs[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtsMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UtsMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsernsMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsernsMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShmSize", wireType)
			}
			m.ShmSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShmSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sysctls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Sysctls == nil {
				m.Sysctls = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Sysctls[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Sysctls[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsoleSizeHeight", wireType)
			}
			m.ConsoleSizeHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsoleSizeHeight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsoleSizeWidth", wireType)
			}
			m.ConsoleSizeWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsoleSizeWidth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Isolation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mounts = append(m.Mounts, &VolumeMount{})
			if err := m.Mounts[len(m.Mounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Init", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Init = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortBinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Value == nil {
				m.Value = make(map[string]*PortBinding)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &PortBinding{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Value[mapkey] = mapvalue
			} else {
				var mapvalue *PortBinding
				m.Value[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Value == nil {
				m.Value = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Value[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Value[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeMount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeMount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeMount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadOnly = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consistency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Consistency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BindOptions == nil {
				m.BindOptions = &BindOptions{}
			}
			if err := m.BindOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeOptions == nil {
				m.VolumeOptions = &VolumeOptions{}
			}
			if err := m.VolumeOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TmpfsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TmpfsOptions == nil {
				m.TmpfsOptions = &TmpfsOptions{}
			}
			if err := m.TmpfsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BindOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BindOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BindOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Propagation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Propagation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCopy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoCopy = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Labels[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Labels[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Driver == nil {
				m.Driver = &DriverConfig{}
			}
			if err := m.Driver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DriverConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DriverConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DriverConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Options == nil {
				m.Options = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Options[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Options[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TmpfsOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TmpfsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TmpfsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeightDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeightDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeightDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThrottleDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThrottleDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThrottleDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ulimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ulimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ulimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hard", wireType)
			}
			m.Hard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hard |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soft", wireType)
			}
			m.Soft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soft |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.EndpointsConfig == nil {
				m.EndpointsConfig = make(map[string]*EndpointSettings)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &EndpointSettings{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.EndpointsConfig[mapkey] = mapvalue
			} else {
				var mapvalue *EndpointSettings
				m.EndpointsConfig[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpamConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpamConfig == nil {
				m.IpamConfig = &EndpointIPAMConfig{}
			}
			if err := m.IpamConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aliases", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aliases = append(m.Aliases, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixLen", wireType)
			}
			m.IpPrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpPrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalIpv6Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalIpv6Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalIpv6PrefixLen", wireType)
			}
			m.GlobalIpv6PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalIpv6PrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.DriverOpts == nil {
				m.DriverOpts = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.DriverOpts[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.DriverOpts[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointIPAMConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointIPAMConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointIPAMConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkLocalIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkLocalIps = append(m.LinkLocalIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pb/moby/api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 2788 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x59, 0xdb, 0x92, 0x1b, 0xb7,
	0xd1, 0xfe, 0xb9, 0x07, 0x1e, 0x9a, 0xe4, 0x1e, 0xb0, 0xab, 0xd5, 0x68, 0x65, 0x49, 0x6b, 0xda,
	0xbf, 0xbc, 0x3e, 0xad, 0x1d, 0x59, 0x65, 0xcb, 0xaa, 0xca, 0x85, 0x0e, 0x3e, 0x6c, 0x59, 0x1b,
	0x29, 0x43, 0xc5, 0xae, 0xca, 0xcd, 0xd4, 0x70, 0x06, 0x22, 0xe1, 0x9d, 0x19, 0x20, 0x03, 0x70,
	0x25, 0xfa, 0x2a, 0x57, 0xb9, 0xca, 0x03, 0x24, 0x55, 0x49, 0x55, 0xde, 0x21, 0xef, 0xe0, 0x72,
	0x55, 0x2e, 0x92, 0x47, 0x48, 0x39, 0x2f, 0x92, 0xea, 0x6e, 0x0c, 0x39, 0x5c, 0x6f, 0x1c, 0xab,
	0x72, 0xc5, 0xc1, 0xd7, 0x0d, 0xa0, 0xd1, 0x68, 0x7c, 0xdd, 0x00, 0x61, 0xdb, 0x8c, 0xde, 0xcb,
	0xf5, 0x68, 0xf6, 0x5e, 0x6c, 0xd4, 0x91, 0x29, 0xb5, 0xd3, 0x62, 0x0d, 0xdb, 0x83, 0xbf, 0x36,
	0xa0, 0xf7, 0xb9, 0x8c, 0x33, 0x37, 0x79, 0xa0, 0x8b, 0x67, 0x6a, 0x2c, 0x04, 0xac, 0x39, 0x69,
	0x5d, 0xd0, 0x38, 0x58, 0x3d, 0xec, 0x84, 0xf4, 0x2d, 0xde, 0x84, 0x2d, 0x55, 0x38, 0x59, 0x9e,
	0xc5, 0x59, 0x64, 0x65, 0xa2, 0x8b, 0xd4, 0x06, 0x2b, 0x07, 0x8d, 0xc3, 0xd5, 0x70, 0xb3, 0xc2,
	0x87, 0x0c, 0x8b, 0x37, 0x60, 0xd3, 0xa9, 0x5c, 0xea, 0xa9, 0x9b, 0x6b, 0xae, 0x92, 0xe6, 0x86,
	0x87, 0x2b, 0xc5, 0x57, 0xa1, 0x67, 0x5d, 0x5c, 0xba, 0xc8, 0xc8, 0x52, 0xe9, 0x34, 0x58, 0x23,
	0xad, 0x2e, 0x61, 0x4f, 0x08, 0x12, 0x01, 0xb4, 0x4a, 0xe9, 0x4a, 0x25, 0x6d, 0xb0, 0x7e, 0xd0,
	0x38, 0x5c, 0x0f, 0xab, 0xe6, 0xe0, 0xef, 0x2d, 0x68, 0x7a, 0x7b, 0xf7, 0xa1, 0x3d, 0xd1, 0xd6,
	0x15, 0x71, 0x2e, 0x83, 0xc6, 0x41, 0xe3, 0xb0, 0x13, 0xce, 0xdb, 0xe2, 0x3a, 0x40, 0xaa, 0xf3,
	0x58, 0x15, 0x24, 0x5d, 0x21, 0x69, 0x0d, 0xc1, 0xb5, 0x4e, 0xad, 0x2c, 0xc9, 0xc2, 0x4e, 0x48,
	0xdf, 0x68, 0x57, 0xec, 0x5c, 0x9c, 0x4c, 0x22, 0xeb, 0x52, 0x55, 0x90, 0x5d, 0xed, 0xb0, 0xcb,
	0xd8, 0x10, 0x21, 0xf1, 0x1a, 0xf4, 0x17, 0x2a, 0x7a, 0xea, 0xc8, 0xba, 0x76, 0xd8, 0x9b, 0xeb,
	0xe8, 0xa9, 0x5b, 0x56, 0x92, 0x65, 0x19, 0x34, 0xcf, 0x29, 0xc9, 0xb2, 0x14, 0xb7, 0xa0, 0x2f,
	0x5f, 0x18, 0x6d, 0x65, 0x1a, 0x19, 0x5d, 0x3a, 0x1b, 0xb4, 0x0e, 0x1a, 0x87, 0xdd, 0x5b, 0xfd,
	0x23, 0xdc, 0x9b, 0xa3, 0x27, 0xba, 0x74, 0x43, 0xe9, 0xc2, 0x9e, 0xd7, 0xc1, 0xb6, 0x15, 0x5b,
	0xb0, 0xea, 0xdc, 0x2c, 0x68, 0xd3, 0x70, 0xf8, 0x29, 0xae, 0x01, 0x68, 0x23, 0x0b, 0x6f, 0x70,
	0x87, 0x04, 0x1d, 0x44, 0xd8, 0xdc, 0x6b, 0x00, 0x24, 0x89, 0x74, 0x91, 0xc8, 0x00, 0x58, 0x4c,
	0xc8, 0xe3, 0x22, 0x91, 0x38, 0x9e, 0x2c, 0xce, 0x82, 0x2e, 0xed, 0x37, 0x7e, 0x22, 0x92, 0xe4,
	0x69, 0xd0, 0x63, 0x24, 0xc9, 0x53, 0x71, 0x1b, 0xba, 0x13, 0x0a, 0x92, 0x64, 0x22, 0x93, 0xd3,
	0xa0, 0x4f, 0x56, 0x0a, 0xb6, 0xb2, 0x1e, 0x3d, 0x61, 0x5d, 0x8d, 0x5c, 0x59, 0x8e, 0x6d, 0x24,
	0x6d, 0x12, 0x1b, 0x99, 0x06, 0x1b, 0xde, 0x95, 0xe5, 0xd8, 0x7e, 0xc2, 0x90, 0xd8, 0x85, 0x75,
	0x95, 0xc7, 0x63, 0x19, 0x6c, 0xd2, 0x16, 0x70, 0x43, 0x7c, 0x00, 0xad, 0x33, 0x9d, 0x4d, 0x73,
	0x69, 0x83, 0xad, 0x83, 0xd5, 0xc3, 0xee, 0xad, 0x2b, 0x3c, 0x15, 0x4f, 0x72, 0xf4, 0x25, 0xcb,
	0x3e, 0x29, 0x5c, 0x39, 0x0b, 0x2b, 0x4d, 0x71, 0x03, 0xba, 0xcf, 0x75, 0x79, 0xaa, 0x8a, 0x71,
	0x94, 0xaa, 0x32, 0xd8, 0xe6, 0xdd, 0xf6, 0xd0, 0x43, 0x55, 0x62, 0x34, 0x48, 0xec, 0x62, 0xb4,
	0x2a, 0x5c, 0x20, 0x68, 0x75, 0x35, 0x04, 0xa3, 0xbc, 0x90, 0x0e, 0x3b, 0x44, 0xa9, 0xb2, 0xf1,
	0x28, 0x93, 0x69, 0xb0, 0x43, 0x26, 0x6f, 0x7a, 0xfc, 0xa1, 0x87, 0x71, 0xae, 0x3c, 0x4e, 0xa2,
	0x38, 0x4d, 0x4b, 0x69, 0x6d, 0xb0, 0xcb, 0x73, 0xe5, 0x71, 0x72, 0x8f, 0x11, 0x71, 0x05, 0xda,
	0xba, 0x88, 0x46, 0x53, 0x95, 0xa5, 0xc1, 0x25, 0x9a, 0xa9, 0xa5, 0x8b, 0xfb, 0xd8, 0x14, 0xef,
	0x43, 0x33, 0x8b, 0x47, 0x32, 0xb3, 0xc1, 0x1e, 0xad, 0x2d, 0x58, 0x5a, 0xdb, 0x23, 0x12, 0xf1,
	0xd2, 0xbc, 0x1e, 0xce, 0x66, 0x9d, 0x36, 0x91, 0x55, 0xe3, 0x22, 0xce, 0x82, 0xcb, 0x3c, 0x1b,
	0x42, 0x43, 0x42, 0xf8, 0x2c, 0x69, 0x13, 0xf9, 0x23, 0x16, 0x04, 0x74, 0x5a, 0xa8, 0xd3, 0x53,
	0x86, 0xd0, 0xd1, 0x76, 0x22, 0xb3, 0x2c, 0xb8, 0x42, 0xd6, 0x70, 0x63, 0xff, 0x04, 0x7a, 0x75,
	0x67, 0xe2, 0xce, 0x9f, 0xca, 0x99, 0x3f, 0x47, 0xf8, 0x29, 0xde, 0x80, 0xf5, 0xb3, 0x38, 0x9b,
	0xf2, 0xe9, 0xe9, 0xde, 0xda, 0x66, 0x63, 0xb9, 0xd3, 0x89, 0x9e, 0x16, 0x2e, 0x64, 0xf9, 0xdd,
	0x95, 0x3b, 0x8d, 0xfd, 0x8f, 0xa1, 0x5b, 0xb3, 0xff, 0x82, 0xd1, 0x76, 0xeb, 0xa3, 0x75, 0x6a,
	0x5d, 0x07, 0x7f, 0x6a, 0x40, 0xe7, 0x91, 0x1e, 0xfb, 0x43, 0x7d, 0x03, 0xba, 0x09, 0x7d, 0x45,
	0x6e, 0x66, 0xaa, 0x73, 0x0d, 0x0c, 0x3d, 0x9d, 0x19, 0x8c, 0x90, 0x26, 0xb7, 0x82, 0x15, 0x72,
	0xe2, 0x55, 0xb6, 0x6b, 0x3e, 0x82, 0x77, 0xa7, 0xf7, 0x23, 0xab, 0xa2, 0x79, 0x35, 0xf8, 0xa5,
	0xcc, 0x1b, 0x42, 0x3f, 0x94, 0xcc, 0x4d, 0x3a, 0x53, 0xc9, 0x0c, 0xa9, 0xa3, 0x46, 0x39, 0xf4,
	0x2d, 0x8e, 0x60, 0x27, 0x8f, 0x5f, 0xa8, 0x7c, 0x9a, 0x47, 0x48, 0x54, 0xb3, 0x28, 0x41, 0x07,
	0xd1, 0x60, 0xeb, 0xe1, 0xb6, 0x17, 0x85, 0x28, 0x79, 0x80, 0x82, 0xc1, 0x5f, 0x00, 0x3a, 0xa1,
	0xb4, 0x7a, 0x5a, 0x26, 0xd2, 0xe2, 0x31, 0x4d, 0xcc, 0x34, 0xb2, 0x93, 0xb8, 0x94, 0x96, 0xc6,
	0x5d, 0x0d, 0x3b, 0x89, 0x99, 0x0e, 0x09, 0x10, 0x7b, 0xd0, 0xcc, 0x65, 0xae, 0xcb, 0x99, 0x67,
	0x5e, 0xdf, 0x12, 0x57, 0xa1, 0x53, 0xc4, 0x85, 0x8e, 0x12, 0x33, 0xad, 0xa8, 0xb6, 0x8d, 0xc0,
	0x03, 0x33, 0xb5, 0x48, 0x42, 0xc9, 0xb8, 0xd4, 0x53, 0x13, 0x99, 0xb8, 0x94, 0x85, 0x23, 0x36,
	0xeb, 0x84, 0x3d, 0x06, 0x9f, 0x10, 0x86, 0xd1, 0x33, 0xca, 0x4e, 0x95, 0x8e, 0x9e, 0x4b, 0x35,
	0x9e, 0x38, 0xcf, 0xb5, 0x5d, 0xc2, 0xbe, 0x22, 0x48, 0xdc, 0x87, 0x9d, 0xba, 0x4a, 0x94, 0xca,
	0x33, 0x95, 0x48, 0xa2, 0xb4, 0x39, 0x0f, 0xb0, 0xea, 0x43, 0x92, 0x84, 0xdb, 0xb5, 0xde, 0x0c,
	0x89, 0xcf, 0xe0, 0x12, 0x8f, 0xc1, 0x9d, 0xa3, 0x52, 0xc6, 0x69, 0x34, 0x32, 0x15, 0xe7, 0xed,
	0xf2, 0x28, 0x4f, 0x27, 0xa5, 0x76, 0x2e, 0x93, 0x7e, 0x1c, 0x41, 0x5d, 0x7c, 0x43, 0xc6, 0xe9,
	0x7d, 0x63, 0xc5, 0x31, 0xec, 0x2d, 0x0d, 0xf4, 0xbc, 0x54, 0x4e, 0xd2, 0x48, 0xed, 0x1f, 0x19,
	0x69, 0xa7, 0x36, 0xd2, 0x57, 0xd8, 0xe3, 0xa2, 0xa1, 0xc8, 0x26, 0xa5, 0x8d, 0x25, 0x16, 0xfd,
	0x29, 0x43, 0xa1, 0x51, 0xc7, 0xda, 0x58, 0xf1, 0x05, 0x5c, 0xbe, 0xc0, 0x2a, 0x1a, 0x0b, 0x7e,
	0x64, 0xac, 0xdd, 0xf3, 0x66, 0xd1, 0x60, 0x3e, 0x16, 0x7c, 0x6a, 0xec, 0xce, 0x63, 0xc1, 0x27,
	0xc6, 0xab, 0x80, 0x8d, 0xe8, 0x37, 0x53, 0xed, 0xe2, 0xa0, 0xc7, 0x7b, 0x9e, 0x98, 0xe9, 0x2f,
	0xb1, 0x8d, 0x51, 0x88, 0xc2, 0x12, 0x89, 0x58, 0xe5, 0xb2, 0x1a, 0xa4, 0x4f, 0x6a, 0xdb, 0x89,
	0x99, 0x86, 0x5e, 0xe2, 0x07, 0x7b, 0x1f, 0x76, 0x97, 0xf4, 0xcb, 0x69, 0x81, 0xbf, 0xc4, 0xd6,
	0xab, 0xa1, 0xa8, 0x75, 0x08, 0x59, 0x42, 0xa7, 0xd3, 0x4c, 0xad, 0x74, 0x1c, 0x74, 0x9b, 0xfe,
	0x74, 0x12, 0x44, 0x61, 0xb7, 0x50, 0xc8, 0x65, 0x8e, 0x1c, 0x5e, 0x53, 0x38, 0x91, 0xb9, 0x15,
	0xef, 0x42, 0x8b, 0xdd, 0x64, 0x83, 0x6d, 0x3a, 0xbf, 0x3b, 0xec, 0x1c, 0xf6, 0xc3, 0x49, 0x6c,
	0x8c, 0x2a, 0xc6, 0x61, 0xa5, 0x83, 0x4b, 0xf2, 0x5e, 0xf5, 0xd1, 0x5c, 0x4e, 0x33, 0x69, 0x3d,
	0x85, 0x6f, 0xb3, 0xe8, 0x01, 0x49, 0x42, 0x14, 0xa0, 0xfb, 0x52, 0x65, 0x4f, 0xbd, 0x83, 0x76,
	0xd8, 0x7d, 0x88, 0xb0, 0x87, 0x5e, 0x83, 0xfe, 0xa9, 0x2c, 0x0b, 0x99, 0x45, 0xfe, 0x44, 0xed,
	0x92, 0x46, 0x8f, 0xc1, 0x13, 0x3e, 0x57, 0xef, 0x82, 0x60, 0x69, 0x54, 0x4a, 0x8b, 0x25, 0x8e,
	0x53, 0xba, 0x08, 0x2e, 0xb1, 0x17, 0x59, 0x12, 0x2e, 0x04, 0x94, 0x11, 0x58, 0xdd, 0x3e, 0x8f,
	0x4d, 0xb0, 0x47, 0x7a, 0xc0, 0xd0, 0xf0, 0x79, 0x6c, 0xc4, 0xdb, 0xb0, 0x5d, 0x53, 0x30, 0xaa,
	0xc0, 0xc4, 0x71, 0x99, 0xd4, 0xb6, 0x16, 0x6a, 0x8c, 0x8b, 0x43, 0xd8, 0xd2, 0x3a, 0x8f, 0x4e,
	0x55, 0x96, 0x55, 0xb9, 0x88, 0x48, 0x7d, 0x35, 0xdc, 0xd0, 0x3a, 0xff, 0x42, 0x65, 0x99, 0x4f,
	0x45, 0xb8, 0x54, 0xa3, 0x52, 0x1b, 0x65, 0x2a, 0x57, 0x2e, 0xb8, 0xc2, 0x4b, 0x45, 0xe4, 0x11,
	0x02, 0xe2, 0x26, 0xb4, 0xa6, 0x24, 0xb2, 0xc1, 0x3e, 0x39, 0xba, 0xc7, 0x8e, 0xfe, 0x15, 0x81,
	0x61, 0x25, 0xac, 0x22, 0x8a, 0x09, 0xeb, 0xea, 0x3c, 0xa2, 0x88, 0xa7, 0xfc, 0x76, 0x62, 0x20,
	0x25, 0xc8, 0x21, 0xaf, 0xf0, 0xda, 0x38, 0x1c, 0x11, 0x11, 0x37, 0x61, 0x53, 0xe9, 0xa8, 0xe2,
	0x3e, 0x8a, 0xf9, 0x6b, 0x07, 0x8d, 0xc3, 0xb5, 0xb0, 0xaf, 0xf4, 0x09, 0xa3, 0x14, 0xd6, 0xef,
	0xc3, 0x6e, 0x4d, 0x6f, 0x14, 0x17, 0xe9, 0x73, 0x95, 0xba, 0x49, 0x70, 0x9d, 0x94, 0xc5, 0x5c,
	0xf9, 0x7e, 0x25, 0x19, 0xfc, 0xbe, 0x01, 0xfd, 0xa5, 0xa0, 0x10, 0x07, 0xd0, 0x33, 0xb1, 0x9b,
	0x44, 0xba, 0x88, 0xb0, 0xce, 0xab, 0x72, 0x03, 0x62, 0x8f, 0x8b, 0xcf, 0xb5, 0x75, 0xe2, 0x2d,
	0xd8, 0x26, 0x0d, 0x55, 0x44, 0x89, 0x2e, 0x5c, 0xac, 0x0a, 0x59, 0x7a, 0x46, 0xdf, 0x44, 0xc1,
	0x71, 0xf1, 0xa0, 0x82, 0x71, 0x97, 0x2b, 0x82, 0x94, 0x65, 0xae, 0xac, 0x55, 0xba, 0xb0, 0xbe,
	0x1e, 0xdc, 0xf6, 0x2c, 0xb9, 0x10, 0x0c, 0xfe, 0xdc, 0x03, 0xc0, 0x39, 0x7c, 0x9a, 0xda, 0x85,
	0xf5, 0x91, 0xc2, 0x12, 0x97, 0x8b, 0x65, 0x6e, 0xe0, 0xfc, 0xf3, 0x79, 0x23, 0x95, 0x46, 0xcf,
	0x54, 0x56, 0x65, 0x94, 0xcd, 0xb9, 0xe0, 0x38, 0xfd, 0x54, 0x65, 0x98, 0x32, 0x20, 0xd3, 0xe3,
	0xc8, 0xe7, 0xb2, 0x55, 0x22, 0x8a, 0xcd, 0x73, 0xb9, 0x2c, 0xec, 0x64, 0xf3, 0xc4, 0xf8, 0x2a,
	0xf4, 0xaa, 0x1a, 0x25, 0xd7, 0xa9, 0xf4, 0x7c, 0xde, 0xf5, 0xd8, 0x89, 0x4e, 0x25, 0xd6, 0x94,
	0x58, 0x4b, 0x46, 0x68, 0x8c, 0x2a, 0xc6, 0x5c, 0x3b, 0x2f, 0xd5, 0x94, 0x27, 0xb1, 0x09, 0x7b,
	0xa8, 0x73, 0xdf, 0xab, 0x88, 0xbb, 0xb0, 0x51, 0x4a, 0x5f, 0x8e, 0x53, 0x7e, 0xf3, 0xd4, 0xee,
	0x8f, 0xe5, 0x52, 0xea, 0x0b, 0xfb, 0xe5, 0x52, 0x26, 0xbc, 0x01, 0xdd, 0x78, 0xea, 0x74, 0x54,
	0xca, 0x5c, 0x9f, 0x49, 0x62, 0xf3, 0x76, 0x08, 0x08, 0x85, 0x84, 0xe0, 0x71, 0xe3, 0x1a, 0x2d,
	0x4a, 0x4b, 0x75, 0x26, 0x4b, 0xa2, 0xe9, 0x4e, 0xd8, 0x63, 0xf0, 0x21, 0x61, 0xb8, 0x30, 0x5f,
	0xc8, 0x45, 0xcf, 0x4a, 0x9d, 0x07, 0x1d, 0xf2, 0x68, 0xd7, 0x63, 0x9f, 0x96, 0x3a, 0x17, 0x97,
	0xa1, 0x95, 0xc4, 0x06, 0x8b, 0xae, 0x00, 0x48, 0xda, 0x4c, 0x62, 0x73, 0x2f, 0x4d, 0xb1, 0xd8,
	0x42, 0x41, 0x5a, 0x6a, 0xe3, 0xcb, 0x58, 0x54, 0x7c, 0x58, 0x6a, 0x83, 0x39, 0x3e, 0x2d, 0x6c,
	0x55, 0xca, 0xa6, 0x05, 0x71, 0x53, 0x5a, 0xd8, 0x48, 0x1b, 0x47, 0x5b, 0xdd, 0xe7, 0x32, 0x30,
	0x2d, 0xec, 0x63, 0x46, 0x88, 0x3c, 0x0a, 0x1b, 0x59, 0x19, 0x97, 0xc9, 0x24, 0xd8, 0x20, 0x79,
	0x27, 0x2d, 0xec, 0x90, 0x00, 0xec, 0x2f, 0x5f, 0xb8, 0x32, 0xa6, 0xe8, 0x43, 0xf2, 0xe3, 0x32,
	0x12, 0x21, 0x8c, 0x0c, 0x3a, 0x4a, 0x1c, 0x51, 0x68, 0xe8, 0x16, 0x89, 0xdb, 0x04, 0x78, 0x53,
	0x95, 0x49, 0x78, 0xef, 0xb8, 0x42, 0x6d, 0x29, 0x93, 0xd0, 0xbe, 0xed, 0x41, 0x93, 0x03, 0x2e,
	0x10, 0x24, 0xf0, 0x2d, 0x0c, 0xb2, 0x4c, 0x15, 0xa7, 0x36, 0xd8, 0xe1, 0x20, 0xa3, 0x86, 0x18,
	0x40, 0x1f, 0x19, 0xc2, 0x26, 0xba, 0x94, 0x51, 0x9c, 0x7e, 0x4d, 0x1c, 0xb6, 0x1e, 0x76, 0xb5,
	0xce, 0x87, 0x88, 0xdd, 0x4b, 0xbf, 0xc6, 0xc9, 0x8c, 0x4a, 0x79, 0xb2, 0x4b, 0x3c, 0x99, 0x51,
	0x29, 0x4d, 0x76, 0x1d, 0xc0, 0x94, 0xea, 0x4c, 0x65, 0x72, 0x2c, 0x53, 0x62, 0xab, 0x76, 0x58,
	0x43, 0xe8, 0x0c, 0x4d, 0x47, 0x99, 0xb2, 0x93, 0x28, 0xce, 0x32, 0x7f, 0x39, 0xb9, 0xcc, 0xc5,
	0xb0, 0x17, 0xdc, 0xcb, 0x32, 0xbe, 0x90, 0xbc, 0x01, 0x9b, 0x98, 0x37, 0x75, 0x91, 0xcd, 0xa2,
	0x52, 0x6b, 0xf7, 0xcc, 0x12, 0x57, 0xb5, 0xc3, 0x8d, 0x0a, 0x0e, 0x09, 0xa5, 0x32, 0x55, 0x26,
	0xd3, 0x52, 0xb9, 0x19, 0xfa, 0xdf, 0x97, 0xa2, 0xdd, 0x0a, 0x7b, 0x6c, 0x9c, 0xb8, 0x47, 0xa5,
	0x6e, 0x19, 0x8f, 0x25, 0x69, 0x30, 0x67, 0x1d, 0xf8, 0x8b, 0xc6, 0xfc, 0xe0, 0x1d, 0x0d, 0x59,
	0xe7, 0xb1, 0x71, 0x5c, 0xe1, 0x81, 0x9d, 0x03, 0xe2, 0x67, 0xb0, 0xee, 0x72, 0xf3, 0xcc, 0x06,
	0x57, 0xeb, 0x95, 0x61, 0xad, 0xf3, 0x53, 0x94, 0x72, 0x3f, 0xd6, 0x44, 0x47, 0x4d, 0x9d, 0x65,
	0x47, 0xbd, 0xc2, 0x8e, 0x9a, 0x3a, 0x4b, 0x8e, 0xba, 0x01, 0x5d, 0xbc, 0x16, 0x16, 0x5e, 0x7a,
	0x8d, 0xd9, 0x86, 0x21, 0x52, 0xb8, 0x02, 0x6d, 0x3b, 0xc9, 0x23, 0xab, 0xbe, 0x91, 0xc4, 0x63,
	0xab, 0x61, 0xcb, 0x4e, 0xf2, 0xa1, 0xfa, 0x46, 0x8a, 0x8f, 0xa0, 0x65, 0x67, 0x36, 0x71, 0x99,
	0x0d, 0x6e, 0x90, 0x2d, 0xd7, 0x7e, 0xb8, 0x10, 0x96, 0xfb, 0xab, 0x8c, 0xd7, 0xa6, 0x8b, 0xaf,
	0xcf, 0xc2, 0x07, 0x6c, 0x8e, 0x6f, 0x52, 0x72, 0xd7, 0x85, 0xd5, 0x99, 0xa4, 0x19, 0xa3, 0x09,
	0x97, 0x6c, 0xaf, 0x1e, 0x34, 0x0e, 0xfb, 0xe1, 0xb6, 0x17, 0xe1, 0xe4, 0x9f, 0x73, 0xe1, 0xf6,
	0x0e, 0x88, 0x25, 0x7d, 0xe6, 0xdb, 0x01, 0xa9, 0x6f, 0xd5, 0xd4, 0xbf, 0x42, 0x5c, 0xbc, 0x02,
	0x1d, 0x65, 0x75, 0xc6, 0xa9, 0xee, 0x35, 0x9a, 0x79, 0x01, 0x88, 0x77, 0xa1, 0x53, 0x56, 0xd5,
	0x6a, 0xf0, 0x7a, 0x9d, 0xaa, 0xe6, 0x45, 0x6c, 0xb8, 0xd0, 0x10, 0x6f, 0x42, 0x33, 0xc7, 0xf4,
	0x61, 0x83, 0xff, 0xa7, 0xc5, 0x5f, 0x70, 0x75, 0xf0, 0x0a, 0x58, 0x4c, 0xab, 0x42, 0xb9, 0xe0,
	0x26, 0x85, 0x0d, 0x7d, 0xef, 0xff, 0x1c, 0x36, 0xcf, 0xed, 0xf2, 0xcb, 0x14, 0xec, 0xfb, 0x77,
	0x00, 0x16, 0xfb, 0xfc, 0x52, 0x3d, 0xef, 0x42, 0xaf, 0xbe, 0x2b, 0x2f, 0x75, 0x4d, 0x78, 0x00,
	0xdd, 0x27, 0x0b, 0x5e, 0x45, 0xc6, 0x42, 0x96, 0x88, 0x94, 0xf1, 0xdd, 0x9b, 0xd8, 0x3c, 0x36,
	0xc8, 0x11, 0x24, 0xc0, 0x73, 0xe5, 0x47, 0xa1, 0x57, 0x0b, 0xec, 0x3c, 0xf8, 0x5d, 0x03, 0x5a,
	0x9e, 0xa6, 0xc5, 0x51, 0x35, 0x55, 0xa3, 0x7e, 0x57, 0xf4, 0xd2, 0xa3, 0x2f, 0x51, 0xe4, 0x23,
	0x99, 0xd4, 0xf6, 0xbf, 0x00, 0x58, 0x80, 0x3f, 0xf9, 0x3a, 0x57, 0xb3, 0xb9, 0xbe, 0x1a, 0xcb,
	0x76, 0x0c, 0xa5, 0xfb, 0x11, 0x3b, 0x86, 0xd2, 0x5d, 0x60, 0xc7, 0x9d, 0xff, 0x62, 0xc7, 0x7f,
	0x76, 0xe1, 0xb7, 0x2b, 0xd0, 0xad, 0xc5, 0x08, 0xd2, 0x31, 0x45, 0x49, 0xfd, 0x26, 0xd8, 0x21,
	0x84, 0x2e, 0x82, 0x7b, 0xd0, 0xe4, 0x80, 0xf3, 0x23, 0xf9, 0x16, 0xe2, 0x2e, 0x2e, 0xc7, 0xd2,
	0xf9, 0x64, 0xee, 0x5b, 0xe8, 0x79, 0x2a, 0xf2, 0x91, 0x96, 0x7c, 0xf6, 0x6c, 0x23, 0xf0, 0xb8,
	0xc8, 0x66, 0xe2, 0x80, 0xae, 0x9d, 0x56, 0x59, 0x27, 0x8b, 0x64, 0x46, 0x89, 0xb3, 0x13, 0xd6,
	0x21, 0x71, 0x1b, 0x7a, 0x98, 0x57, 0xe7, 0xe9, 0xa3, 0x59, 0x77, 0x23, 0xba, 0xd0, 0x67, 0x91,
	0xb0, 0x3b, 0x5a, 0x34, 0x30, 0xbd, 0xfa, 0x0c, 0x58, 0xf5, 0x6b, 0xd5, 0xd3, 0x2b, 0x2f, 0xb7,
	0xea, 0xe9, 0x93, 0x65, 0xd5, 0xf7, 0x23, 0xe8, 0x13, 0x49, 0xcd, 0xbb, 0xb6, 0xeb, 0x97, 0x2e,
	0x8a, 0xf1, 0xaa, 0x67, 0xcf, 0xd5, 0x5a, 0x83, 0xf7, 0xa0, 0x5b, 0x33, 0x08, 0xd7, 0x66, 0x4a,
	0x6d, 0xe2, 0x31, 0x9f, 0x6e, 0x76, 0x64, 0x1d, 0x1a, 0x7c, 0xd7, 0x80, 0xfe, 0x92, 0x29, 0x18,
	0xbf, 0x78, 0xb3, 0xd4, 0x86, 0xf7, 0xae, 0x1d, 0x36, 0x0b, 0xfd, 0x40, 0x9b, 0x99, 0xf8, 0x68,
	0xfe, 0x86, 0xc1, 0xd7, 0xef, 0x1b, 0x17, 0x2c, 0xe4, 0xc2, 0xa7, 0x8c, 0xb7, 0xa0, 0xe9, 0x8b,
	0x80, 0xd5, 0xfa, 0x32, 0xb8, 0x08, 0xf0, 0xe5, 0x8e, 0xd7, 0xf8, 0x5f, 0x5e, 0x13, 0xfe, 0xd8,
	0x80, 0x5e, 0x7d, 0xcc, 0x0b, 0xaf, 0xeb, 0x1f, 0x43, 0xab, 0xf2, 0xe9, 0xd2, 0x2a, 0xea, 0x1d,
	0x8f, 0xfc, 0x62, 0x3c, 0x41, 0x7b, 0x7d, 0xe4, 0x88, 0xba, 0xe0, 0xa5, 0x6c, 0xbb, 0x07, 0xbd,
	0xfa, 0xae, 0xd1, 0xf3, 0x1c, 0x52, 0xf3, 0x68, 0xe6, 0x16, 0xf7, 0x7e, 0x44, 0xee, 0x23, 0x80,
	0x96, 0x53, 0xe6, 0x59, 0x21, 0xce, 0xa6, 0xef, 0xc1, 0x5d, 0xe8, 0x2d, 0x5d, 0xad, 0x05, 0xac,
	0x61, 0x61, 0x5b, 0xad, 0x0e, 0xbf, 0xf1, 0x00, 0xf8, 0xfb, 0x3c, 0xbf, 0x3f, 0xf8, 0xd6, 0xe0,
	0x0e, 0x6c, 0x2c, 0x5f, 0x41, 0x2f, 0xec, 0x2d, 0x60, 0xad, 0x8c, 0x1d, 0xcf, 0xba, 0x16, 0xd2,
	0xf7, 0xe0, 0x21, 0x34, 0xf9, 0xda, 0x70, 0xa1, 0x37, 0x05, 0xac, 0x4d, 0xe2, 0x32, 0xf5, 0xaf,
	0x13, 0xf4, 0x8d, 0x98, 0xd5, 0xcf, 0x9c, 0x7f, 0x96, 0xa0, 0xef, 0xc1, 0xb7, 0x0d, 0xd8, 0xfa,
	0x05, 0x97, 0xab, 0xaa, 0xa8, 0xca, 0xda, 0x2f, 0x61, 0x4b, 0x16, 0x29, 0x3d, 0xc3, 0xd9, 0xaa,
	0x18, 0x66, 0xa6, 0x79, 0x9b, 0xf7, 0xe4, 0x7c, 0x8f, 0xa3, 0x4f, 0x2a, 0xf5, 0xfa, 0x43, 0xcf,
	0xa6, 0x5c, 0x46, 0xf7, 0x7f, 0x0d, 0xbb, 0x17, 0x29, 0x5e, 0xb0, 0x5f, 0xef, 0x2c, 0x13, 0xe3,
	0x1e, 0x4f, 0x5b, 0x75, 0x1e, 0x4a, 0xe7, 0xb0, 0x50, 0xae, 0xef, 0xe3, 0xdf, 0xd6, 0x60, 0xeb,
	0xbc, 0x5c, 0x7c, 0x0c, 0x5d, 0x65, 0xe2, 0x7c, 0xb1, 0x86, 0xc6, 0x82, 0x2d, 0x2b, 0xe5, 0xe3,
	0x27, 0xf7, 0x4e, 0x7c, 0xa8, 0x03, 0x2a, 0x2f, 0x2e, 0x13, 0x5c, 0xe7, 0xad, 0xd4, 0xeb, 0xbc,
	0x00, 0x5a, 0x71, 0xa6, 0x62, 0x2b, 0xf1, 0x56, 0x42, 0xa5, 0xad, 0x6f, 0x62, 0xdc, 0x54, 0x57,
	0x01, 0x95, 0x7a, 0x2a, 0xeb, 0x78, 0xe4, 0x98, 0x9e, 0x28, 0x2b, 0x6f, 0xa0, 0x9c, 0xb9, 0x0c,
	0x2a, 0xe8, 0x98, 0x5e, 0xd7, 0xc7, 0xb1, 0x93, 0xcf, 0x63, 0x2e, 0xf6, 0x3b, 0x61, 0xd5, 0xc4,
	0x91, 0x95, 0x99, 0x3f, 0x6e, 0xb6, 0x7c, 0x1d, 0x60, 0xaa, 0xb7, 0xcd, 0x01, 0xf4, 0x95, 0x89,
	0x4c, 0x29, 0x9f, 0xa9, 0x17, 0x51, 0x26, 0x0b, 0x62, 0xa4, 0xf5, 0xb0, 0xab, 0xcc, 0x13, 0xc2,
	0x1e, 0xc9, 0x02, 0x4b, 0x3d, 0x65, 0xce, 0x3e, 0x8c, 0xaa, 0x19, 0x3a, 0x4c, 0x37, 0x88, 0x7d,
	0xe6, 0x67, 0x39, 0x82, 0x9d, 0x71, 0xa6, 0x47, 0x71, 0x16, 0x91, 0x66, 0x35, 0x1d, 0xf0, 0xdd,
	0x8b, 0x45, 0xc7, 0xe6, 0xec, 0xc3, 0x6a, 0xda, 0x0f, 0x60, 0xaf, 0xae, 0x5f, 0x9b, 0xbf, 0x4b,
	0xf3, 0xef, 0x2c, 0xba, 0x2c, 0xec, 0x38, 0xf7, 0x50, 0xdb, 0xfb, 0xc1, 0x43, 0xed, 0x67, 0xd0,
	0x65, 0xba, 0x41, 0x7e, 0xe5, 0xeb, 0x40, 0xf7, 0xd6, 0xcd, 0x8b, 0x77, 0xdf, 0x33, 0xc3, 0x63,
	0xe3, 0x3c, 0x1f, 0x40, 0x3a, 0x07, 0xb0, 0x5e, 0x39, 0x27, 0x7e, 0x29, 0x56, 0xf8, 0x6d, 0x03,
	0xc4, 0x0f, 0x03, 0xc4, 0xfb, 0xf1, 0xf6, 0x7c, 0x01, 0x8d, 0xb9, 0x1f, 0x6f, 0x57, 0x2b, 0xa8,
	0x5c, 0x5d, 0xa9, 0xac, 0x2c, 0x5c, 0x5d, 0xa9, 0xbc, 0x0e, 0x1b, 0x18, 0x4d, 0x51, 0xa6, 0x13,
	0x72, 0x5f, 0x15, 0x4b, 0x3d, 0x44, 0x1f, 0x21, 0x78, 0x6c, 0xec, 0xfd, 0xad, 0xef, 0xbe, 0xbf,
	0xde, 0xf8, 0xc7, 0xf7, 0xd7, 0x1b, 0xff, 0xfc, 0xfe, 0x7a, 0xe3, 0x0f, 0xff, 0xba, 0xfe, 0x7f,
	0xa3, 0x26, 0xfd, 0x53, 0xf4, 0xc1, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xad, 0x6d, 0xb4, 0x80,
	0x3e, 0x1a, 0x00, 0x00,
}
